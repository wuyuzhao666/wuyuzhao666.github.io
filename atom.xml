<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xCAFEBABE的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuyuzhao666.github.io/"/>
  <updated>2019-06-10T06:21:08.200Z</updated>
  <id>http://wuyuzhao666.github.io/</id>
  
  <author>
    <name>Wu yuzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nio之零拷贝</title>
    <link href="http://wuyuzhao666.github.io/2019/06/04/Nio%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D/Nio%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>http://wuyuzhao666.github.io/2019/06/04/Nio之零拷贝/Nio之零拷贝/</id>
    <published>2019-06-04T00:36:01.000Z</published>
    <updated>2019-06-10T06:21:08.200Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux中的内核态与用户态"><a href="#Linux中的内核态与用户态" class="headerlink" title="Linux中的内核态与用户态"></a>Linux中的内核态与用户态</h4><center><img src="http://res.cloudinary.com/cafebabe/zc-1"></center><p>如上图所示，<code>Unix/Linux</code>的体系架构分为内核空间（kernal space）与用户空间(application space)，内核控制着计算机的硬件资源，为上层应用程序提供运行环境。用户空间就是应用程序的活动空间，而内核为应用程序的执行提供着必要的cpu、存储、IO资源等。为了使应用程序访问使用到这些资源，内核就提供了资源访问的接口：系统调用。</p><h4 id="传统IO的拷贝"><a href="#传统IO的拷贝" class="headerlink" title="传统IO的拷贝"></a>传统IO的拷贝</h4><center><img src="http://res.cloudinary.com/cafebabe/zc-2"></center><ul><li>数据先从硬件资源被<strong>拷贝</strong>到<strong>内核空间</strong>的缓冲区中(<code>kernel buffer</code>)。</li><li>然后再从<strong>内核空间</strong>的缓冲区中拷贝到<strong>用户空间</strong>的缓冲区（<code>application buffer</code>）中。</li><li>接着从<strong>用户空间</strong>再拷贝到<strong>内核空间</strong>中的<code>Socket buffer</code>/<code>Write buffer</code>中。</li><li>最后再从<code>Socket buffer</code>中拷贝到<strong>网卡缓冲区</strong>/<strong>硬件资源</strong>中。</li></ul><blockquote><p>这个过程经过了<strong>4次</strong>的数据拷贝，其中有<strong>2次</strong>（1和4）是<code>DMA</code>拷贝（直接内存拷贝，不需要<code>cpu</code>的参与），2和3是<code>cpu</code>拷贝。</p></blockquote><p>应用程序发起了<code>read</code>和<code>write</code>系统调用，会经过<strong>4次</strong>的上下文切换。</p><center><img src="http://res.cloudinary.com/cafebabe/zc-3"></center><h4 id="Nio中的零拷贝"><a href="#Nio中的零拷贝" class="headerlink" title="Nio中的零拷贝"></a>Nio中的零拷贝</h4><h5 id="sendFile零拷贝"><a href="#sendFile零拷贝" class="headerlink" title="sendFile零拷贝"></a>sendFile零拷贝</h5><p>在<code>Java</code>的<code>Nio</code>中有个<code>transferTo()</code>方法，可以将一个<code>channel</code>里面的字节直接复制到另一个可以写入字节的<code>channel</code>中，此方法比从通道读取并写入目标通道的简单循环更有效。操作系统可以直接从文件系统缓存向目标通道传输字节，而无需实际复制它们。<code>transferTo()</code>最后内部封装的是<code>sendFile</code>这个系统调用。</p><p>基本代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8898</span>));</span><br><span class="line">        String fileName = <span class="string">"/home/Desktop/pycharm-professional-2019.1.2.tar.gz"</span>;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        FileChannel channel = fileInputStream.getChannel();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">long</span> transfer = channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的流程如下：</p><center><img src="http://res.cloudinary.com/cafebabe/zc-4"></center><ul><li>应用程序调用<code>transferTo</code>方法，即<code>JVM</code>发起<code>sendFile</code>系统调用，从用户态切换到内核态（<strong>第一次上下文切换</strong>）。</li><li>内核将数据从硬件资源里<strong>DMA拷贝</strong>到内核空间的缓冲区中。</li><li>然后经过<strong>CPU拷贝</strong>到<code>Socket buffer</code>中。</li><li>接着<code>sendFile</code>系统调用返回，将数据<strong>DMA拷贝</strong>到<strong>网卡缓冲区</strong>/<strong>硬件资源</strong>中（<strong>第二次上下文切换</strong>）。</li></ul><blockquote><p>虽然在内核态时，经过了一次cpu拷贝，但并没有从内核态切换到用户态，对于操作系统来说，这已经是零拷贝了（DMA拷贝需要连续的内存空间，所以需要缓冲区）。如果底层操作系统支持分散与收集（scatter and gather）的话，就可以实现真正意义上的零拷贝。</p></blockquote><h5 id="收集拷贝功能的零拷贝"><a href="#收集拷贝功能的零拷贝" class="headerlink" title="收集拷贝功能的零拷贝"></a>收集拷贝功能的零拷贝</h5><center><img src="http://res.cloudinary.com/cafebabe/zc-7"></center><ul><li>应用程序调用<code>transferTo</code>方法，即<code>JVM</code>发起<code>sendFile</code>系统调用，从用户态切换到内核态（<strong>第一次上下文切换</strong>）。</li><li>内核将数据从硬件资源里<strong>DMA拷贝</strong>到内核空间的缓冲区中。</li><li>现在并没有数据会拷贝到<code>Socket buffer</code>，而是<code>Read buffer</code>中数据的相关描述信息（<code>Read buffer</code>缓冲区的内存地址以及偏移量，即长度）会被拷贝到<code>Socket buffer</code>中（即图中的<code>Descriptor</code>）。</li><li>接着<code>sendFile</code>系统调用返回，<strong>DMA gather copy</strong>根据<code>Socket buffer</code>中的描述信息（<strong>第二次上下文切换</strong>）直接将数据从内核空间拷贝<strong>网卡缓冲区</strong>/<strong>硬件资源</strong>中。</li></ul><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>零拷贝提升了文件读写的速度，但是因为没有经过<strong>用户态</strong>，用户程序无法对文件进行操作，所以零拷贝应应用于不需要对文件进行操作的读写场景，但又想提高速度，但又需要对数据进行操作怎么办？那就应该使用<strong>NIO的直接内存</strong>。它的具体实现是通过<code>mmap</code><strong>内存映射</strong>系统调用完成的，它是一个优于传统IO但比<code>sendFile</code>昂贵的IO方法。</p><center><img src="http://res.cloudinary.com/cafebabe/zc-9"></center><ul><li>应用程序调发起<code>mmap</code>系统调用，从用户态切换到内核态（<strong>第一次上下文切换</strong>）。</li><li>通过<strong>DMA引擎</strong>将数据从硬件拷贝到内核空间缓冲区。</li><li><code>mmap</code>系统调用返回，内核态切换为用户态（<strong>第二次上下文切换</strong>）。用户空间和内核空间就共享这一片缓冲区，而不需要将数据从内核空间拷贝到用户空间。因为用户空间和内核空间共享了这个缓冲区数据，所以用户空间就可以像在操作自己缓冲区中数据一般操作这个由内核空间共享的缓冲区数据。</li><li>应用程序发起<code>write</code>系统调用，用户态切换到内核态（<strong>第三次上下文切换</strong>）。</li><li>数据经过<strong>CPU拷贝</strong>到<code>Socket buffer</code>中。</li><li><code>write</code>系统调用返回，内核态切换为用户态（<strong>第四次上下文切换</strong>）。 </li><li>数据通过<strong>DMA引擎</strong>拷贝到<strong>网卡缓冲区</strong>/<strong>硬件资源</strong>中。</li></ul><h5 id="NIO中的直接内存"><a href="#NIO中的直接内存" class="headerlink" title="NIO中的直接内存"></a>NIO中的直接内存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">""</span>).getChannel();</span><br><span class="line"><span class="comment">//map方法接受3个参数</span></span><br><span class="line"><span class="comment">//FileChannel.MapMode mode：</span></span><br><span class="line"><span class="comment">//Read-only:只读</span></span><br><span class="line"><span class="comment">//Read_write:对结果缓冲区所做的更改最终会传播到文件中;它们可能会或可能不会被映射到同一文件的其他程序看到。 </span></span><br><span class="line"><span class="comment">//privarte:对结果缓冲区所做的更改不会传播到文件，并且对于映射了同一文件的其他程序不可见;相反，它将导致被修改部分缓冲区独自拷贝一份到用户空间。</span></span><br><span class="line"><span class="comment">//position:映射区域的起始位置。</span></span><br><span class="line"><span class="comment">//size:要映射区域的大小。</span></span><br><span class="line">MappedByteBuffer map = channel.map(FileChanne.MapMode.READ_ONLY, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>NIO</code>的直接内存是由<code>MappedByteBuffer</code>实现的。核心即是<code>map()</code>方法，该方法把文件映射到内存中，获得内存地址<code>addr</code>，然后通过这个<code>addr</code>构造<code>MappedByteBuffer</code>类，以暴露各种文件操作<code>API</code>。</p><p>由于<code>MappedByteBuffer</code>申请的是堆外内存，因此<strong>不受Minor GC控制</strong>，只能在发生<code>Full GC</code>时才能被回收。而<code>DirectByteBuffer</code>改善了这一情况，它是<code>MappedByteBuffer</code>类的子类，同时它实现了<code>DirectBuffer</code>接口，维护一个<code>Cleaner</code>对象来完成内存回收。因此它既可以通过<strong>Full GC</strong>来回收内存，也可以调用<code>clean()</code>方法来进行回收。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Linux中的内核态与用户态&quot;&gt;&lt;a href=&quot;#Linux中的内核态与用户态&quot; class=&quot;headerlink&quot; title=&quot;Linux中的内核态与用户态&quot;&gt;&lt;/a&gt;Linux中的内核态与用户态&lt;/h4&gt;&lt;center&gt;&lt;img src=&quot;http://
      
    
    </summary>
    
      <category term="Java基础" scheme="http://wuyuzhao666.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="nio" scheme="http://wuyuzhao666.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>解决Gradle、Maven项目buildg后没有mybatis的mapper.xml文件问题</title>
    <link href="http://wuyuzhao666.github.io/2019/05/31/%E8%A7%A3%E5%86%B3Gradle%E5%92%8CMaven%E9%A1%B9%E7%9B%AEbuildg%E5%90%8E%E6%B2%A1%E6%9C%89mybatis%E7%9A%84mapper-xml%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/%E8%A7%A3%E5%86%B3Gradle%E5%92%8CMaven%E9%A1%B9%E7%9B%AEbuildg%E5%90%8E%E6%B2%A1%E6%9C%89mybatis%E7%9A%84mapper-xml%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://wuyuzhao666.github.io/2019/05/31/解决Gradle和Maven项目buildg后没有mybatis的mapper-xml文件问题/解决Gradle和Maven项目buildg后没有mybatis的mapper-xml文件问题/</id>
    <published>2019-05-31T13:09:59.000Z</published>
    <updated>2019-05-31T13:19:26.326Z</updated>
    
    <content type="html"><![CDATA[<p><code>Gradle</code>、<code>Maven</code>都默认只把<code>resources</code>目录当作资源目录，所以在编译时就不会把<code>java</code>目录下的<code>mapper.xml</code>文件编译到输出目录，所以需要在相关文件中修改默认资源目录。</p><ul><li><p>Maven</p><p>在<code>pom</code>文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Gradle</p><p>在build.gradle文件中加入</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceSets.main.resources.srcDirs = [<span class="string">"src/main/java"</span>,<span class="string">"src/main/resources"</span>]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Gradle&lt;/code&gt;、&lt;code&gt;Maven&lt;/code&gt;都默认只把&lt;code&gt;resources&lt;/code&gt;目录当作资源目录，所以在编译时就不会把&lt;code&gt;java&lt;/code&gt;目录下的&lt;code&gt;mapper.xml&lt;/code&gt;文件编译到输出目录
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nio：Selector示例解析</title>
    <link href="http://wuyuzhao666.github.io/2019/05/30/nio%EF%BC%9ASelector%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/nio%EF%BC%9ASelector%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://wuyuzhao666.github.io/2019/05/30/nio：Selector示例解析/nio：Selector示例解析/</id>
    <published>2019-05-30T02:45:09.000Z</published>
    <updated>2019-05-30T06:16:12.665Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nio三大核心概念"><a href="#Nio三大核心概念" class="headerlink" title="Nio三大核心概念"></a>Nio三大核心概念</h4><p><code>Nio</code>中有三大核心概念：<code>Buffer</code>、<code>Channel</code>、<code>Selector</code>。</p><ul><li><p><code>Buffer</code>本身是一块内存，底层实现上，是一个数组。数据的读写都是通过<code>Buffer</code>实现的。所有的数据的读写都是通过<code>Buffer</code>来进行的，永远不会出现直接向<code>Channel</code>读写的情况。</p><p>具体原理与<code>API</code>：<a href="https://www.cnblogs.com/chenpi/p/6475510.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpi/p/6475510.html</a></p></li><li><p><code>Channel</code>指的是可以向其读写数据的对象，类似于<code>java.io</code>中的<code>Stream</code>。<code>Stream</code>只能是<code>InputStream</code>或者<code>OutputStream</code>，<code>Channel</code>所不同的是，<code>Channel</code>是双向的，<code>Channel</code>打开后，则可以进行读取、写入。</p></li><li><p><code>Selector</code>可以管理着多条<code>Channel</code>通道，并且可以知晓这些通道是否为<code>Accept</code>、<code>Connect</code>、<code>Read</code>、<code>Write</code>做好了准备。通过<code>Selector</code>可以管理多个网络连接，也就是说，在一个线程中就可以管理多个<code>Channel</code>，这也是跟传统<code>io</code>的区别，这样单线程的话，减少了线程上下文切换的开销。</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>服务端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存通道的map，以通道的地址作为key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,SocketChannel&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel实例，并绑定端口</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//使用Selector，必须处于非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>));</span><br><span class="line">        <span class="comment">//创建一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//将channel注册到selector上，并绑定selector对于此通道的感兴趣的事件，当此通道`接受就绪`时，selector就可以知道此通道`接受就绪`。这样就实现了通道和Selector的关联关系。共有四种常量状态</span></span><br><span class="line">        <span class="comment">//SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">//SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">//SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">//SelectionKey.OP_WRITE</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//返回keys的数量，若没有，在阻塞一段时间后，返回0</span></span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (select == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//获取SelectionKey集合，通过这些SelectionKey可以获取到相应的就绪通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</span></span><br><span class="line">            selectionKeys.forEach(selectionKey -&gt; &#123;</span><br><span class="line">                <span class="keyword">final</span> SocketChannel client;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(selectionKey.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">//如果有客户端连接服务，触发accept事件</span></span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                        client = channel.accept();</span><br><span class="line">                        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        String s = client.getRemoteAddress().toString();</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                        <span class="comment">//在selector上注册socketChannel的OP_READ事件。</span></span><br><span class="line">                        client.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">//将通道放入map中保存</span></span><br><span class="line">                        map.put(s,client);</span><br><span class="line">                        <span class="comment">//从 selectionKeys删除掉已处理的selectionKey，不然会一直循环</span></span><br><span class="line">                        selectionKeys.remove(selectionKey);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//如果有客户端发送数据，触发read事件</span></span><br><span class="line">                        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//将数据读到Buffer中</span></span><br><span class="line">                        <span class="keyword">int</span> write = socketChannel.read(byteBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (write &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//将position移到0处</span></span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            Charset charset = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line">                            <span class="comment">//解码出字符串</span></span><br><span class="line">                            String valueOf = String.valueOf(charset.decode(byteBuffer));</span><br><span class="line">                            System.out.println(valueOf);</span><br><span class="line">                            SocketAddress remoteAddress = socketChannel.getRemoteAddress();</span><br><span class="line">                            <span class="comment">//将服务端接收到的数据，发送给其他的客户端，通过保存在map中CHannel</span></span><br><span class="line">                            <span class="comment">//比较</span></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;String,SocketChannel&gt; entry:</span><br><span class="line">                                 map.entrySet()) &#123;</span><br><span class="line">                                SocketChannel value = entry.getValue();</span><br><span class="line">                                <span class="comment">//如果map中的Channel等于当前Channel，就不发送给这个Channel，这样就只有别的客户端嫩收到消息</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != socketChannel) &#123;</span><br><span class="line">                                        byteBuffer.clear();</span><br><span class="line">                                        byteBuffer.put( valueOf.getBytes());</span><br><span class="line">                                        byteBuffer.flip();</span><br><span class="line">                                        value.write(byteBuffer);</span><br><span class="line">                                    &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    selectionKeys.remove(selectionKey);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8899</span>));</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">         <span class="comment">//将channel注册到selector上，并绑定selector对于此通道的感兴趣的事件，当此通道`接收连接`时，selector就可以知道此通道`接受连接`。这样就实现了通道和Selector的关联关系。</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">         <span class="keyword">if</span>(select == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            selectionKeys.forEach(selectionKey -&gt; </span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isConnectable())&#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//判断连接是否完成</span></span><br><span class="line">                    <span class="keyword">if</span>(channel.isConnectionPending())&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            channel.finishConnect();</span><br><span class="line">                            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            byteBuffer.put((LocalDateTime.now() + <span class="string">" connect successed!"</span>).getBytes());</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            channel.write(byteBuffer);</span><br><span class="line">                            <span class="comment">//通过单线程池创建获取键盘输入的线程</span></span><br><span class="line">                            ExecutorService executorService = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());</span><br><span class="line">                            executorService.submit(() -&gt; &#123;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                                    byteBuffer.clear();</span><br><span class="line">                                    InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">                                    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">                                    String s = bufferedReader.readLine();</span><br><span class="line">                                    byteBuffer.put((channel.getLocalAddress().toString() + <span class="string">" : "</span>+ s).getBytes());</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    channel.write(byteBuffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//将通道绑定为读事件</span></span><br><span class="line">                        channel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line">                            <span class="keyword">if</span>(read &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                            String s = <span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, read);</span><br><span class="line">                            System.out.println(s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    selectionKeys.remove(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Nio三大核心概念&quot;&gt;&lt;a href=&quot;#Nio三大核心概念&quot; class=&quot;headerlink&quot; title=&quot;Nio三大核心概念&quot;&gt;&lt;/a&gt;Nio三大核心概念&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Nio&lt;/code&gt;中有三大核心概念：&lt;code&gt;Buffer&lt;/cod
      
    
    </summary>
    
      <category term="Java基础" scheme="http://wuyuzhao666.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="nio" scheme="http://wuyuzhao666.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>linux下安装thrift填坑记</title>
    <link href="http://wuyuzhao666.github.io/2019/05/22/linux%E4%B8%8B%E5%AE%89%E8%A3%85thrift%E5%A1%AB%E5%9D%91%E8%AE%B0/linux%E4%B8%8B%E5%AE%89%E8%A3%85thrift%E5%A1%AB%E5%9D%91%E8%AE%B0/"/>
    <id>http://wuyuzhao666.github.io/2019/05/22/linux下安装thrift填坑记/linux下安装thrift填坑记/</id>
    <published>2019-05-22T11:19:40.000Z</published>
    <updated>2019-05-22T11:44:39.090Z</updated>
    
    <content type="html"><![CDATA[<h5 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h5><p>（基于centos6）最近想安装个<code>thrift</code>来玩玩，看了网上的一些安装教程，报了一大堆的错，查了无数的资料，搞了一天，终于安装好了。。。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>依赖安装</span><br><span class="line">yum -y update</span><br><span class="line">yum install wget</span><br><span class="line">yum install git</span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line">yum install libevent-devel zlib-devel openssl-devel</span><br><span class="line">yum install m4</span><br><span class="line">yum install glibc-devel glibc glib2 glib2-devel</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>autoconf</span><br><span class="line">yum install autoconf-2.69</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>libtool</span><br><span class="line">wget http://mirrors.ustc.edu.cn/gnu/libtool/libtool-2.4.6.tar.gz</span><br><span class="line">tar -xvf libtool-2.4.6.tar.gz</span><br><span class="line">cd libtool-2.4.6</span><br><span class="line">./bootstrap</span><br><span class="line">./configure</span><br><span class="line">make &amp;make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>bison</span><br><span class="line">wget http://ftp.gnu.org/gnu/bison/bison-3.0.4.tar.gz</span><br><span class="line">tar -xvf bison-3.0.4.tar.gz</span><br><span class="line">cd bison-3.0.4</span><br><span class="line">./configure --prefix=/usr/soft/bison</span><br><span class="line">make &amp;make install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>bootstrap</span><br><span class="line">wget http://sourceforge.net/projects/boost/files/boost/1.64.0/boost_1_64_0.tar.gz</span><br><span class="line">tar -xvf boost_1_64_0.tar.gz</span><br><span class="line">cd boost_1_64_0</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./b2 install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>thrift，若时间很久，直接去官网下载吧 </span><br><span class="line"><span class="meta">#</span>http://www.apache.org/dyn/closer.cgi?path=/thrift/0.12.0/thrift-0.12.0.tar.gz</span><br><span class="line">git clone https://github.com/apache/thrift.git</span><br><span class="line">cd thrift</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure --prefix=/usr/soft/thrift --with-boost=/usr/soft/bootstrap/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>若出现如下错误，NO.1--------------------------------------------------------------------1</span><br><span class="line">./configure: line 3802: PKG_PROG_PKG_CONFIG: command not found</span><br><span class="line">./configure: line 18272: syntax error near unexpected token `QT,'</span><br><span class="line">./configure: line 18272: `    PKG_CHECK_MODULES(QT, QtCore &gt;= 4.3, QtNetwork &gt;= 4.3, have_qt=yes, have_qt=no)'</span><br><span class="line"><span class="meta">#</span>运行如下命令</span><br><span class="line">find /usr -name "pkg.m4"   返回  /usr/share/aclocal/pkg.m4</span><br><span class="line">aclocal --print-ac-dir     返回  /usr/local/share/aclocal</span><br><span class="line"><span class="meta">#</span>这两个地址不一样，再加上 bootstrap.sh 里面定义了  aclocal -I ./aclocal</span><br><span class="line"><span class="meta">#</span>这导致定义在 pkg.m4里全局变量 PKG_PROG_PKG_CONFIG  与 PKG_CHECK_MODULES 找不到，所以报错</span><br><span class="line"><span class="meta">#</span>做如下修改解决这个问题, 在bootstrap.sh 里面修改 </span><br><span class="line">aclocal -I ./aclocal -I /usr/share/aclocal/</span><br><span class="line"><span class="meta">#</span>保存 重新从 ./bootstrap.sh 就可以了！</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>然后继续</span><br><span class="line">make &amp;make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>若出现如下错误，NO.2-------------------------------------------------------------------2</span><br><span class="line"><span class="meta">#</span>搞忘了，反正错误就是你的gcc版本太低了，需要升级</span><br><span class="line"><span class="meta">#</span>下载gcc-4.8</span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.0/gcc-4.8.0.tar.bz2</span><br><span class="line">tar jxvf gcc-4.8.0.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>下载编译所需依赖库</span><br><span class="line">cd gcc-4.8.0</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>编译安装</span><br><span class="line">mkdir gcc-build-4.8.0</span><br><span class="line">cd  gcc-build-4.8.0</span><br><span class="line">../gcc-4.8.0/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">make -j 8</span><br><span class="line">make install</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>若出现如下错误，NO.3-------------------------------------------------------------------3</span><br><span class="line">./src/thrift/server/TNonblockingServer.h:41:33: error: event2/event_compat.h: No such file or directory</span><br><span class="line"><span class="meta">#</span>找不到event2的头文件</span><br><span class="line"><span class="meta">#</span>直接去官网下载</span><br><span class="line"><span class="meta">#</span>https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz</span><br><span class="line"><span class="meta">#</span>安装编译</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>若出现如下错误，NO.4-------------------------------------------------------------------4</span><br><span class="line">/usr/lib/libstdc++.so.6: version `GLIBCXX_3.4.18' not found </span><br><span class="line"><span class="meta">#</span>这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库，将gcc最新版本的动态库替换掉老版本的动态库即可</span><br><span class="line"><span class="meta">#</span>查看GLBCXX版本</span><br><span class="line">strings /usr/lib/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line"><span class="meta">#</span>输出</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_FORCE_NEW</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line"><span class="meta">#</span>可以看到，最高版本为3.4.13，没有对应的3.4.18</span><br><span class="line"><span class="meta">#</span>查看libstdc++.so.6链接的库</span><br><span class="line">ll /usr/lib/libstdc++.so.6</span><br><span class="line"><span class="meta">#</span>输出，这是libstdc++.so.6现在链接的库</span><br><span class="line">/usr/lib/libstdc++.so.6 -&gt; libstdc++.so.6.0.13 </span><br><span class="line"><span class="meta">#</span>查看系统更高版本的lib库</span><br><span class="line">find / -name libstdc++.so.6*</span><br><span class="line"><span class="meta">#</span>输出，这里有一个6.0.18版本，比libstdc++.so.6.0.13版本更高  </span><br><span class="line">/usr/lib64/libstdc++.so.6.bak</span><br><span class="line">/usr/lib64/libstdc++.so.6.0.13</span><br><span class="line">/usr/lib64/libstdc++.so.6</span><br><span class="line">/usr/lib64/libstdc++.so.6.0.20</span><br><span class="line">/usr/local/lib64/libstdc++.so.6</span><br><span class="line">/usr/local/lib64/libstdc++.so.6.0.18-gdb.py</span><br><span class="line">/usr/local/lib64/libstdc++.so.6.0.18  </span><br><span class="line"><span class="meta">#</span>查看lib库的信息</span><br><span class="line">strings /usr/local/lib/libstdc++.so.6.0.18 | grep GLIBCXX</span><br><span class="line"><span class="meta">#</span>输出，18这个版本满足我们的需求</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18 </span><br><span class="line">GLIBCXX_FORCE_NEW</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line"><span class="meta">#</span>重新链接</span><br><span class="line">cp /usr/local/lib/libstdc++.so.6.0.20 /usr/lib64/libstdc++.so.6.0.18</span><br><span class="line">rm -f /usr/lib/libstdc++.so.6</span><br><span class="line">ln -s /usr/lib/libstdc++.so.6.0.20 /usr/lib64/libstdc++.so.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>若出现如下错误，NO.5-------------------------------------------------------------------5</span><br><span class="line">g++: error: /usr/lib/libboost_unit_test_framework.a: No such file or directory</span><br><span class="line"><span class="meta">#</span>查找文件</span><br><span class="line">find / -name libboost_unit_test_framework.a</span><br><span class="line"><span class="meta">#</span>输出</span><br><span class="line">/usr/local/lib/libboost_unit_test_framework.a</span><br><span class="line"><span class="meta">#</span>解决</span><br><span class="line">sudo ln -s /usr/local/lib/libboost_unit_test_framework.a /usr/lib/libboost_unit_test_framework.a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>编译</span><br><span class="line">make &amp;make install</span><br><span class="line">成功</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h5&gt;&lt;p&gt;（基于centos6）最近想安装个&lt;code&gt;thrift&lt;/code&gt;来玩玩，看了网上的一些安装教程，报了一大堆的错，查了无数的资料，搞了
      
    
    </summary>
    
      <category term="thrift" scheme="http://wuyuzhao666.github.io/categories/thrift/"/>
    
    
  </entry>
  
  <entry>
    <title>protobuf集成netty实现多协议消息传递</title>
    <link href="http://wuyuzhao666.github.io/2019/05/21/protobuf%E9%9B%86%E6%88%90netty%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/protobuf%E9%9B%86%E6%88%90netty%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>http://wuyuzhao666.github.io/2019/05/21/protobuf集成netty实现多协议消息传递/protobuf集成netty实现多协议消息传递/</id>
    <published>2019-05-21T11:37:28.000Z</published>
    <updated>2019-05-21T12:14:34.520Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>当使用<code>socket</code>传输数据时，客户端服务端进行交互时，必须要知道数据类型，才能将数据序列化，在使用<code>protobuf</code>进行序列化时，可以使用官方推荐的方式实现多数据类型的传输。</p><h5 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">message MyMessage&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> DataType&#123;</span><br><span class="line">        StudentType = <span class="number">1</span>;</span><br><span class="line">        DogType = <span class="number">2</span>;</span><br><span class="line">        TeacherType =<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required DataType data_type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    oneof dataBody&#123;</span><br><span class="line">        Student student = <span class="number">2</span>;</span><br><span class="line">        Teacher teacher = <span class="number">3</span>;</span><br><span class="line">        Dog dog = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Student &#123;</span><br><span class="line">    required string name = <span class="number">1</span>;</span><br><span class="line">    optional int32 id = <span class="number">2</span>;</span><br><span class="line">    optional string email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Dog &#123;</span><br><span class="line">    required string name = <span class="number">1</span>;</span><br><span class="line">    optional string type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Teacher &#123;</span><br><span class="line">    required string name = <span class="number">1</span>;</span><br><span class="line">    optional string address = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>.proto</code>文件中定义一个“外部”的类来进行包装所想要传递的一些数据类型，用枚举类型来表示包装在其中的数据类型是什么，<code>data_type</code>就来指明数据类型，<code>dataBody</code>就是所要传输的数据。</p><blockquote><p><code>oneof</code>官方解释：如果有一个包含许多字段的消息，并且最多只能同时设置一个字段，则可以使用<code>oneof</code>功能强制执行此行为并节省内存。</p></blockquote><p><code>oneof</code>里面可以包含许多数据类型，但是只会被设置一个数据类型，且设置了一个<code>oneof</code>字段后会清空掉前面所设置的其他<code>oneof</code>成员，所有这样可以节省许多内存。</p><h5 id="集成netty"><a href="#集成netty" class="headerlink" title="集成netty"></a>集成netty</h5><h6 id="Initializer"><a href="#Initializer" class="headerlink" title="Initializer"></a>Initializer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProtoInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解码器，通过Google Protocol Buffers序列化框架动态的切割接收到的ByteBuf</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">        <span class="comment">//服务端\客户端接收的是DataInfo对象，所以这边将接收对象进行解码生产实列</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufDecoder(DataInfo.MyMessage.getDefaultInstance()));</span><br><span class="line">        <span class="comment">//Google Protocol Buffers编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">        <span class="comment">//Google Protocol Buffers编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyProtoServerHandler());</span><br><span class="line">        <span class="comment">//pipeline.addLast(new MyProtoClientHandler());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Serverhandler"><a href="#Serverhandler" class="headerlink" title="Serverhandler"></a>Serverhandler</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProtoServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">DataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//服务端随机的发送Student、Teacher、Dog到客户端</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        DataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//创建一个包装了Student的MyMessage的实例</span></span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.StudentType)</span><br><span class="line">                    .setStudent(DataInfo.Student.newBuilder().</span><br><span class="line">                            setName(<span class="string">"student"</span>).setEmail(<span class="string">"qq@qqq"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//创建一个包装了Teacher的MyMessage的实例</span></span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.TeacherType)</span><br><span class="line">                    .setTeacher(DataInfo.Teacher.newBuilder().</span><br><span class="line">                            setName(<span class="string">"teacher"</span>).setAddress(<span class="string">"chengdu"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个包装了Dog的MyMessage的实例</span></span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.DogType)</span><br><span class="line">                    .setDog(DataInfo.Dog.newBuilder().</span><br><span class="line">                            setName(<span class="string">"dog"</span>).setType(<span class="string">"erha"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.channel().writeAndFlush(myMessage);</span><br><span class="line"><span class="comment">//打印出客户端发送到服务端的数据</span></span><br><span class="line">        DataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span> (dataType == DataInfo.MyMessage.DataType.StudentType)&#123;</span><br><span class="line">            DataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">            System.out.println(student.getEmail());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == DataInfo.MyMessage.DataType.TeacherType)&#123;</span><br><span class="line">            DataInfo.Teacher teacher = msg.getTeacher();</span><br><span class="line">            System.out.println(teacher.getName());</span><br><span class="line">            System.out.println(teacher.getAddress());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            DataInfo.Dog dog = msg.getDog();</span><br><span class="line">            System.out.println(dog.getName());</span><br><span class="line">            System.out.println(dog.getType());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ClientHandler"><a href="#ClientHandler" class="headerlink" title="ClientHandler"></a>ClientHandler</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProtoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">DataInfo</span>.<span class="title">MyMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DataInfo.MyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//打印服务端传输过来的数据</span></span><br><span class="line">        DataInfo.MyMessage.DataType dataType = msg.getDataType();</span><br><span class="line">        <span class="keyword">if</span> (dataType == DataInfo.MyMessage.DataType.StudentType)&#123;</span><br><span class="line">            DataInfo.Student student = msg.getStudent();</span><br><span class="line">            System.out.println(student.getName());</span><br><span class="line">            System.out.println(student.getEmail());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataType == DataInfo.MyMessage.DataType.TeacherType)&#123;</span><br><span class="line">            DataInfo.Teacher teacher = msg.getTeacher();</span><br><span class="line">            System.out.println(teacher.getName());</span><br><span class="line">            System.out.println(teacher.getAddress());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            DataInfo.Dog dog = msg.getDog();</span><br><span class="line">            System.out.println(dog.getName());</span><br><span class="line">            System.out.println(dog.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//先服务端发送数据</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        DataInfo.MyMessage myMessage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">0</span>)&#123;</span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.StudentType)</span><br><span class="line">                    .setStudent(DataInfo.Student.newBuilder().</span><br><span class="line">                            setName(<span class="string">"student"</span>).setEmail(<span class="string">"qq@qqq"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span>)&#123;</span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.TeacherType)</span><br><span class="line">                    .setTeacher(DataInfo.Teacher.newBuilder().</span><br><span class="line">                            setName(<span class="string">"teacher"</span>).setAddress(<span class="string">"chengdu"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            myMessage = DataInfo.MyMessage.newBuilder().</span><br><span class="line">                    setDataType(DataInfo.MyMessage.DataType.DogType)</span><br><span class="line">                    .setDog(DataInfo.Dog.newBuilder().</span><br><span class="line">                            setName(<span class="string">"dog"</span>).setType(<span class="string">"erha"</span>).build()).</span><br><span class="line">                            build();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.channel().writeAndFlush(myMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;当使用&lt;code&gt;socket&lt;/code&gt;传输数据时，客户端服务端进行交互时，必须要知道数据类型，才能将数据序列化，在使用&lt;code&gt;pr
      
    
    </summary>
    
      <category term="netty" scheme="http://wuyuzhao666.github.io/categories/netty/"/>
    
    
      <category term="protobuf集成netty" scheme="http://wuyuzhao666.github.io/tags/protobuf%E9%9B%86%E6%88%90netty/"/>
    
  </entry>
  
  <entry>
    <title>jenkins自动化构建部署到多个服务器</title>
    <link href="http://wuyuzhao666.github.io/2019/05/12/jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://wuyuzhao666.github.io/2019/05/12/jenkins自动化构建部署到多个服务器/jenkins自动化构建部署到多个服务器/</id>
    <published>2019-05-12T07:12:42.000Z</published>
    <updated>2019-05-12T09:43:11.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jenkins下载与安装"><a href="#jenkins下载与安装" class="headerlink" title="jenkins下载与安装"></a>jenkins下载与安装</h2><p><code>jenkins</code>是一款持续集成的软件，最开始想用这个软件进行项目的自动化构建部署，是由实验室的项目有三个版本，本地需要一套，测试要一套，交付维护需要一套，每次修改了代码后，都需要打成<code>war</code>包，然后通过一些<code>ftp</code>工具传过去，这样一次还好，次数多了就受不了了，所以就花了一天，学习了下<code>jenkins</code>，以后就方便多了。</p><h5 id="引言与建议"><a href="#引言与建议" class="headerlink" title="引言与建议"></a>引言与建议</h5><p>如果要先集群服务器部署，不免每台有些配置信息不一样，比如数据库连接、<code>rest</code>接口、检索地址、文件服务器地址等，此时最好，将配置文件从<code>jar</code>包里抽取出来，放置在一个固定的目录下，且命名都相同，比如，我是使用<code>/usr/test.properties</code>等。然后写代码读取、或者直接<code>Spring</code>读取就行。</p><p><code>Spring</code>读取外部文件的配置。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"ConfigurerProperty"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"order"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"ignoreResourceNotFound"</span> value=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">"ignoreUnresolvablePlaceholders"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">"location"</span> value=<span class="string">"file:/usr/resources.properties"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h5 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h5><p><a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>下载安装好后，找到<code>jenkins</code>的<code>war</code>包<code>jenkins.war</code>，因为它是自带<code>Jetty</code>服务器的，所以直接命令运行就行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure><blockquote><p>windows下在jenkins目录下打开命令窗口执行就好了。</p></blockquote><p>也可以，把这个<code>war</code>包放置在一个<code>Web</code>容器中。</p><p>然后，就可以通过<code>http://localhost:8080</code>访问。</p><p>按提示，注册账号，按提示登陆，默认安装插件就<code>OK</code>。</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li><p>点击左侧的系统管理</p><center><img src="http://res.cloudinary.com/cafebabe/jks-1"></center></li><li><p>主要对系统设置、全局工具配置、插件管理来进行配置</p><center><img src="http://res.cloudinary.com/cafebabe/jks-2"></center><ul><li><p>插件管理</p><center><img src="http://res.cloudinary.com/cafebabe/jks-3"></center><p>点击可选插件，搜索安装：</p><p><code>Publish Over SSH</code>用于连接远程服务器。</p><p><code>Deploy to container</code>插件用于把打包的应用发布到远程服务器。</p></li><li><p>全局工具设置</p><blockquote><p>不要使用自动安装</p></blockquote><p><code>JDK</code>配置，<code>JAVA_HOME</code>就是自己的<code>jdk</code>目录。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-4"></center><p><code>Maven</code>配置，<code>MAVEN_HOME</code>就是自己的<code>Maven</code>目录。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-5"></center><p><code>git</code>，默认就行。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-7"></center></li><li><p>系统设置，设置远程服务器</p><p>可设置多个节点，点击<code>add</code>。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-6"></center></li></ul></li></ul><h2 id="构建与部署"><a href="#构建与部署" class="headerlink" title="构建与部署"></a>构建与部署</h2><p>配置好后，就可以进行新建任务了。</p><ul><li><p>新建任务</p><center><img src="http://res.cloudinary.com/cafebabe/jks-8"></center></li><li><p>配置</p><ul><li><p>仓库配置</p><center><img src="http://res.cloudinary.com/cafebabe/jks-9"></center><p>若仓库地址有错，会报错。</p></li><li><p>触发器构建</p><p>选择了定时构建和轮询<code>SCM</code>，就可以实现我们的自动化构建了。</p><p>一、定时构建：不管<code>SVN</code>或<code>Git</code>中数据有无变化，均执行定时化的构建任务 ；</p><p>二、轮询<code>SCM</code>：只要<code>SVN</code>或<code>Git</code>中数据有更新，则执行构建任务；</p><p>三、构建语法说明：</p><ul><li>首先格式为：<em> </em> <em> </em> *（五个星）；</li><li>第一个<em>表示分钟，取值0~59 第二个</em>表示小时，取值0~23<br> 第三个<em>表示一个月的第几天，取值1~31 第四个</em>表示第几月，取值1~12<br> 第五个*表示一周中的第几天，取值0~7，其中0和7代表的都是周日</li><li>使用举例：<br> 每隔10分钟构建一次：H/5 <em> </em> <em> </em><br> 每隔1小时构建一次：  H H/1 <em> </em> <em><br> 每月30号构建一次：    H H 30 </em> <em><br> 每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午4:38)<br> H H(9-16)/2 </em> * 1-5</li></ul><p>四、定时构建和轮询<code>SCM</code>使用互不冲突，具体如何组合，需要根据项目情况合理配置；</p><center><img src="http://res.cloudinary.com/cafebabe/jks-10"></center></li><li><p>部署</p><center><img src="http://res.cloudinary.com/cafebabe/jks-11"></center><p>在构建后操作处添加要部署的远程服务器，我这里添加了两个节点。</p><blockquote><p>Name : 在系统设置里配置的服务器，直接选择就行。</p><p>Source files：项目构建后的目录</p><p>Remove prefix ： 去前缀</p><p>Remote directoty ： 发布的目录，这个目录是接着你在远程服务器中配置的目录</p><p>Exec command ： 发布完执行的命令，一般会写个重启Tomcat的脚本，这里是直接执行这个脚本</p></blockquote></li><li><p>构建部署</p><center><img src="http://res.cloudinary.com/cafebabe/jks-12"></center><p>点击立即构建测试，点击控制台输出，可以查看日志输出。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-13"></center><p>以下为三台服务器都部署成功，且成功执行脚本。</p><center><img src="http://res.cloudinary.com/cafebabe/jks-14"></center><p>restart.sh脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line">export JAVA_HOME=/usr/jdk1.8.0_191 </span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">tomcat_home=/home/admin/apache-tomcat-8.5.35</span><br><span class="line">SHUTDOWN=$tomcat_home/bin/shutdown.sh</span><br><span class="line">STARTTOMCAT=$tomcat_home/bin/startup.sh</span><br><span class="line">echo "关闭$tomcat_home"</span><br><span class="line"><span class="meta">$</span>SHUTDOWN</span><br><span class="line"><span class="meta">#</span>杀死tomcat进程</span><br><span class="line">ps -ef|grep tomcat|grep -v grep|awk '&#123;print $2&#125;'|xargs kill -9</span><br><span class="line"><span class="meta">#</span>删除日志文件，如果你不先删除可以不要下面一行</span><br><span class="line">rm  $tomcat_home/logs/* -rf</span><br><span class="line"><span class="meta">#</span>删除tomcat的临时目录</span><br><span class="line">rm  $tomcat_home/work/* -rf</span><br><span class="line">sleep 5</span><br><span class="line"></span><br><span class="line">echo "启动$tomcat_home"</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>STARTTOMCAT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>看启动日志</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>tail -f $tomcat_home/logs/catalina.out</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jenkins下载与安装&quot;&gt;&lt;a href=&quot;#jenkins下载与安装&quot; class=&quot;headerlink&quot; title=&quot;jenkins下载与安装&quot;&gt;&lt;/a&gt;jenkins下载与安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;jenkins&lt;/code&gt;是一款持续集成的软件
      
    
    </summary>
    
      <category term="工具" scheme="http://wuyuzhao666.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="jenkins" scheme="http://wuyuzhao666.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>深度分析ConcurrentLinkedQueue原理</title>
    <link href="http://wuyuzhao666.github.io/2019/04/23/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90ConcurrentLinkedQueue%E5%8E%9F%E7%90%86/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90ConcurrentLinkedQueue%E5%8E%9F%E7%90%86/"/>
    <id>http://wuyuzhao666.github.io/2019/04/23/深度分析ConcurrentLinkedQueue原理/深度分析ConcurrentLinkedQueue原理/</id>
    <published>2019-04-23T12:19:04.000Z</published>
    <updated>2019-04-24T02:18:55.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在<code>JUC</code>包中提供了许多线程安全的并发容器，使用这些容器，无需我们再去手动的设置锁，就能实现线程安全。在这些并发容器中，又分为阻塞与非阻塞（简单来说线程进行元素的放置与取出操作时，可以将线程阻塞）。<code>ConcurrentLinkedQueue</code>就是以非阻塞方式来实现的，这个并发容器类通过循环<code>CAS</code>操作来实现线程安全队列，它不会导致当前线程被暂停，因此也避免了线程上下文切换的开销。</p><blockquote><p>阻塞容器可以通过锁来实现线程安全的，而非阻塞则通过<code>CAS</code>来实现。</p></blockquote><h3 id="CAS的原理"><a href="#CAS的原理" class="headerlink" title="CAS的原理"></a>CAS的原理</h3><p><code>CAS</code>(Compare and Swap)：比较并交换。它是对一种处理器指令的称呼，在<code>Java</code>中，<code>CAS</code>通过调用<code>JNI</code>的代码实现的。<code>CAS</code>操作顾名思义，先比较再交换（或者说更新），通过一段伪代码来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(V a, V b ,V c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//a为想要修改的变量，b为当前线程调用CAS操作时a的值（即a的旧值），c为新值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(b == a)&#123; <span class="comment">//检查其他线程是否已经对a进行了修改</span></span><br><span class="line">            b = c; <span class="comment">//更新</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//更新成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//更新操作</span></span><br><span class="line">    &#125;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当某个线程要执行<code>CAS</code>操作时，如果想要修改的值与调用<code>CAS</code>操作的线程所提供的旧值相同时，说明其他线程并未对其进行修改，则这个线程可以对其进行修改。而其他的线程则更新失败，然后继续进行尝试，直至成功。</p></blockquote><h3 id="ConcurrentLinkedQueue原理"><a href="#ConcurrentLinkedQueue原理" class="headerlink" title="ConcurrentLinkedQueue原理"></a>ConcurrentLinkedQueue原理</h3><p>简单来说，<code>ConcurrentLinkedQueue</code>就相当于<code>LinkedList</code>的线程安全版，即是一个单向链表，在其内部有个私有静态类<code>Node&lt;E&gt;</code>，通过这个类，将元素封装在其中，并保存下一个节点（<code>next</code>）,<code>Node&lt;E&gt;</code>内部通过一个<code>UNSAFE</code>类来完成<code>CAS</code>操作。</p><p>Node类的主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item; <span class="comment">// volatile声明</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next; <span class="comment">// volatile声明</span></span><br><span class="line">        <span class="comment">// 构造方法  在地址itemOffset处， 值替换为item</span></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS操作：比较并交换，原子的更改itemOffset地址的变量。如果变量的值为cmp，并成功替换为val 返回true  </span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 将nextOffset地址的值替换为x</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS操作：比较并交换，原子的更改nextOffset地址的变量。如果变量的值为cmp，并成功替换为val 返回true</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 静态代码块，获取itemOffset和nextOffset</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class k = Node.class;</span><br><span class="line">                itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>tail</code>节点与<code>head</code>节点的<code>CAS</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// CAS操作：比较并交换，原子的更改tailOffset地址的变量。如果变量的值为cmp，并成功替换为val 返回true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casTail</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, cmp, val);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// CAS操作：比较并交换，原子的更改headOffset地址的变量。如果变量的值为cmp，并成功替换为val 返回true</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, cmp, val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>用到的<code>UNSAFE</code>类方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取f在堆内存的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态f在堆内存的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子的更改offset地址的变量。如果变量的值为expected，并成功替换为x 返回true  CAS操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected,Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将offset地址的值替换为x，并且通知其他线程。因为有Volatile，与putObject类似</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取地址为offset 的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span></span><br></pre></td></tr></table></figure><p>在<code>ConcurrentLinkedQueue</code>中维护了两个变量<code>tail</code>和<code>head</code>，并且在创建<code>ConcurrentLinkedQueue</code>实例时，创建一个空节点，并将其赋值于<code>tail</code>和<code>head</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入队列-add"><a href="#入队列-add" class="headerlink" title="入队列(add)"></a>入队列(add)</h4><p>入队列就是将新创建的<code>Node</code>节点添加到队列尾部，它的添加过程如下（图片来自<a href="http://www.ifeve.com）。" target="_blank" rel="noopener">www.ifeve.com）。</a></p><center><img src="http://res.cloudinary.com/cafebabe/clq-1"></center><ul><li>第一步，将元素<code>1</code>节点添加到<code>head</code>节点后面，即<code>head</code>节点的<code>next</code>节点为元素<code>1</code>，因为初始化<code>ConcurrentLinkedQueue</code>时，<code>tail</code>节点和<code>head</code>节点是同一个节点。</li><li>第二步，将元素<code>2</code>节点设置为元素<code>1</code>节点的<code>next</code>节点，将<code>tail</code>节点设置为元素<code>2</code>节点。</li><li>~~</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">    <span class="comment">//创建一个新的入队节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"><span class="comment">//创建一个指向尾节点的引用t，相当于一个中间变量，用于和p比较的</span></span><br><span class="line">    <span class="comment">//p表示尾节点</span></span><br><span class="line">    <span class="comment">//死循环，一直进行CAS操作的尝试，值至成功，返回true</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">         <span class="comment">//获取p节点的下一节点</span></span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="comment">//如果q为空，则p为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//p为尾节点，将新节点添加到p节点之后，CAS操作：比较并交换，如果nextOffset的值等于null的话，说明别的线程还未对其进行修改，则此次CAS操作成功，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">//如果p不等于t，相当于tail不是尾节点，则通过CAS操作将新节点设置为尾节点，如果失败  了，则说明其他线程已将其进行了修改</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t) </span><br><span class="line">                        <span class="comment">//如果tailOffset的值为t，则尝试将新节点设置为尾节点</span></span><br><span class="line">                        casTail(t, newNode);  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果，p等于q，说明p和q都为空，即ConcurrentLinkedQueue刚刚初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            </span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            <span class="comment">//p有next节点，表示p的next节点是尾节点，则需要重新更新p后将它指向next节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                </span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>首先获取尾节点。</p></li><li><p>然后判断尾节点的<code>next</code>节点是否为空。</p><ul><li><p>如果为空，就尝试使用<code>CAS</code>操作添加节点</p><ul><li>如果成功，返回<code>true</code>。</li><li>如果失败，表示其他线程已经添加了新节点，则需要重新获取尾节点。</li></ul></li><li><p>如果不为空，表明其他线程已经添加了新节点进来。</p><ul><li>刚初始化。</li><li>更新尾节点。</li></ul></li></ul></li></ul><p>通过分析可知，每次入队时，都会先定位尾节点，定位成功后，通过<code>p.casNext(null, newNode)</code>这个<code>CAS</code>操作来进行入队操作，因为<code>p</code>和<code>t</code>不是每次都相同，即不是每次入队都会重新设置<code>tail</code>节点，这样减少了<code>casTail(t, newNode)</code>这个设置尾节点的<code>CAS</code>操作的数量，减少了开销，提高了入队的效率。</p></blockquote><h4 id="出队列（poll）"><a href="#出队列（poll）" class="headerlink" title="出队列（poll）"></a>出队列（poll）</h4><p>出队列就是从队列中弹出<code>head</code>节点，将其引用清空，并返回节点中的元素。</p><center><img src="http://res.cloudinary.com/cafebabe/clq-2"></center><p>出队列同入队列一样，不是每次进行出队列操作，都会更新<code>head</code>节点，只有当<code>head</code>节点的元素为空时，才会进行更新<code>head</code>节点的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死循环，进行出队列操作，直到成功，才返回，要么返回一个item，要么返回null。</span></span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//创建一个指向头节点的引用h，相当于一个中间变量，用于和p比较的</span></span><br><span class="line"><span class="comment">//p表示头节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="comment">//item为头节点的元素</span></span><br><span class="line">            E item = p.item;</span><br><span class="line"><span class="comment">//如果p节点元素不为空，则使用CAS操作：如果当前线程的item地址的值等于itemOffset地址的值，就将p节点的元素值设置为空，并返回item</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">              <span class="comment">//如果p不等于h，即head不是头节点，将p的next节点设置为头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) </span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表明已是最后一个节点，跳出循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//p与q相同，q和p都为空，跳到外层循环，重新开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="comment">//p有next节点，设置p指向它的next节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>首先获取头节点的元素。</li><li>然后判断头节点元素是否为空。<ul><li>如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走。</li><li>如果非空，则使用<code>CAS</code>操作将头节点的引用设置成<code>null</code>。<ul><li>如果<code>CAS</code>成功，则直接返回头节点的元素。</li><li>如果不成功，表示另外一个线程已经进行了一次出队操作更新了<code>head</code>节点，导致元素发生了变化，需要重新获取头节点。</li></ul></li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;JUC&lt;/code&gt;包中提供了许多线程安全的并发容器，使用这些容器，无需我们再去手动的设置锁，就能实现线程安全。在这些并发容器
      
    
    </summary>
    
      <category term="Java并发" scheme="http://wuyuzhao666.github.io/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发容器" scheme="http://wuyuzhao666.github.io/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux下搭建shdowsocks服务端</title>
    <link href="http://wuyuzhao666.github.io/2019/04/18/linux%E4%B8%8B%E6%90%AD%E5%BB%BAshdowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF/linux%E4%B8%8B%E6%90%AD%E5%BB%BAshdowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>http://wuyuzhao666.github.io/2019/04/18/linux下搭建shdowsocks服务端/linux下搭建shdowsocks服务端/</id>
    <published>2019-04-18T05:48:38.000Z</published>
    <updated>2019-04-21T13:33:59.467Z</updated>
    
    <content type="html"><![CDATA[<p>作为中国的IT从业人员，有时需要翻越长城，浏览一下国外的网站，这时就可以购买一台位于国外节点的云服务器搭建<code>shdowsocks</code>服务端，然后自己的多终端设备都可以连接这个服务端，跨过长城。</p><h3 id="连接云服务器"><a href="#连接云服务器" class="headerlink" title="连接云服务器"></a>连接云服务器</h3><ul><li><p>首先，购买一台云服务器，任意平台的云服务器都可以，AWS、阿里云、腾讯云皆可，不过国内的相对便宜些，有些会有学生优惠，这里以阿里云为例。</p><blockquote><p>按需购买好云服务器后，会有一个密钥对文件，阿里云可以创建实例时绑定密钥，也可以创建好后再绑定。</p><center><img src="http://res.cloudinary.com/cafebabe/ss-1"></center></blockquote></li><li><p>然后，使用这个<code>.pem</code>文件连接云服务器，此处以<code>Xshell</code>连接为例。</p><blockquote><p>用户名默认为<code>root</code>，密码选择<code>Public Key</code>导入你的密钥文件，即可连接。</p><center><img src="http://res.cloudinary.com/cafebabe/ss-2"></center></blockquote></li></ul><h3 id="安装Shadowsocks服务端"><a href="#安装Shadowsocks服务端" class="headerlink" title="安装Shadowsocks服务端"></a>安装Shadowsocks服务端</h3><h4 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h4><p>使用包管理工具<code>pip</code>安装<code>python</code>版本的<code>Shadowsocks</code>，先安装<code>pip</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># curl "https://bootstrap.pypa.io/get-pip.py" -o "get-pip.py"</span></span><br><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># python get-pip.py</span></span><br></pre></td></tr></table></figure><h4 id="安装配置Shadowsocks服务端"><a href="#安装配置Shadowsocks服务端" class="headerlink" title="安装配置Shadowsocks服务端"></a>安装配置Shadowsocks服务端</h4><p>安装<code>Shadowsocks</code>，此版本的 <code>shadowsocks</code> 已发布到<code>pip</code>上，直接使用<code>pip</code>安装。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># pip install --upgrade pip</span></span><br><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># pip install shadowsocks</span></span><br></pre></td></tr></table></figure><p>安装完成后，再创建一个<code>shadowsocks.json</code>文件，通过读取这个文件的配置来启动，就不用每次启动都输入所有的配置信息。</p><ul><li><p>多端口配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># vim /etc/shadowsocks.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="string">"port_password"</span>: &#123;</span><br><span class="line">    <span class="string">"123456"</span>: <span class="string">"填写密码"</span>,</span><br><span class="line">    <span class="string">"123457"</span>: <span class="string">"填写密码"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"timeout"</span>: <span class="number">600</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"rc4-md5"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>其中<code>server</code>为你的云服务器的<code>私有地址</code>、<code>私有地址</code>、<code>私有地址</code>(说三遍)</li><li><code>method</code>为加密方法，有多种选择，推荐使用<code>rc4-md5</code>，这种方式，加密开销小些。</li></ul></blockquote></li><li><p>单端口配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>: <span class="number">12345</span>,</span><br><span class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"cowbeer"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"rc4-md5"</span>,</span><br><span class="line">    <span class="string">"fast_open"</span>: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h3><p>编辑<code>shadowsocks</code>服务的启动脚本文件，内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># vim /etc/systemd/system/shadowsocks.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=<span class="number">0</span></span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>执行以下命令启动 <code>shadowsocks</code>服务：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># systemctl enable shadowsocks</span></span><br><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># systemctl start shadowsocks</span></span><br></pre></td></tr></table></figure><p>检查 <code>shadowsocks</code> 服务是否已成功启动，可以执行以下命令查看服务的状态：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># systemctl status shadowsocks -l</span></span><br></pre></td></tr></table></figure><center><img src="http://res.cloudinary.com/cafebabe/ss-3"></center><br>### 检查防火墙<br><br>安装无误后，若开启了防火墙，配置防火墙规则，开放你配置的端口：<br><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># firewall-cmd --zone=public --add-port=123456/tcp --permanent</span></span><br><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># firewall-cmd --zone=public --add-port=123457/tcp --permanent</span></span><br><span class="line">[root@iZt4n2suiu81ljhwj0y8ppZ ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure><br><br>以下为未开启防火墙的输出结果：<br><br><center><img src="http://res.cloudinary.com/cafebabe/ss-5"></center></li></ul><h3 id="云服务器配置安全组"><a href="#云服务器配置安全组" class="headerlink" title="云服务器配置安全组"></a>云服务器配置安全组</h3><p><code>shdowsocks</code>安装配置完后，还需要配置安全组。</p><blockquote><p>安全组是一种虚拟防火墙，具备状态检测和数据包过滤功能，用于在云端划分安全域。可以通过配置安全组规则，允许或禁止安全组内的ECS实例对公网或私网的访问。</p></blockquote><p>点开相应实例的左侧的网络与安全的安全组，配置安全组规则：</p><center><img src="http://res.cloudinary.com/cafebabe/ss-6"></center><blockquote><ul><li>安全组出方向默认允许所有访问，即从安全组内ECS访问外部都是放行的。</li><li>端口范围：刚刚配置的<code>shdowsocks</code>的端口，1/12345表示1到12345.</li><li>授权对象：0.0.0.0/0，本机就行。</li></ul></blockquote><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><p>安装配置完后，就可以用<code>shdowsocks</code>客户端进行连接了。</p><p>Windows版本的客户端下载地址：</p><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>无需安装，点开后，添加一个你刚刚配置的服务端的信息，就可以使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为中国的IT从业人员，有时需要翻越长城，浏览一下国外的网站，这时就可以购买一台位于国外节点的云服务器搭建&lt;code&gt;shdowsocks&lt;/code&gt;服务端，然后自己的多终端设备都可以连接这个服务端，跨过长城。&lt;/p&gt;
&lt;h3 id=&quot;连接云服务器&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Linux" scheme="http://wuyuzhao666.github.io/categories/Linux/"/>
    
    
      <category term="shdowsocks" scheme="http://wuyuzhao666.github.io/tags/shdowsocks/"/>
    
  </entry>
  
  <entry>
    <title>部署Web应用到Tomcat根目录</title>
    <link href="http://wuyuzhao666.github.io/2019/04/15/%E9%83%A8%E7%BD%B2Web%E5%BA%94%E7%94%A8%E5%88%B0Tomcat%E6%A0%B9%E7%9B%AE%E5%BD%95/%E9%83%A8%E7%BD%B2Web%E5%BA%94%E7%94%A8%E5%88%B0Tomcat%E6%A0%B9%E7%9B%AE%E5%BD%95/"/>
    <id>http://wuyuzhao666.github.io/2019/04/15/部署Web应用到Tomcat根目录/部署Web应用到Tomcat根目录/</id>
    <published>2019-04-15T02:17:50.000Z</published>
    <updated>2019-04-15T02:40:17.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>Tomcat</code>安装后，默认目录是<code>/webapps/ROOT</code>，我们自己的<code>Web</code>应用就需要以<code>localhost:8080/test</code>这种方式来访问，有时需要将Web应用部署到<code>Tomcat</code>根目录下，就可以<code>localhost:8080</code>这种方式访问。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>首先，进入<code>Tomcat</code>的<code>conf</code>文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 conf]# cd /home/apache-tomcat-8.5.35/conf</span><br></pre></td></tr></table></figure></li><li><p>然后，打开<code>server.xml</code>配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 conf]# vi server.xml</span><br></pre></td></tr></table></figure></li><li><p>在<code>&lt;Host&gt;&lt;/Host&gt;</code>区域的末尾添加</p><blockquote><context path docbase="/home/apache-tomcat-8.5.35/webapps/test" debug="0" reloadable="true"></context></blockquote><p><code>docBase</code>中为在<code>webapps</code>中的<code>Web</code>应用的地址。</p><blockquote><p>使用/pattern：从光标开始处向文件尾搜索pattern</p><p>/&lt;Host</p></blockquote><center><img src="http://res.cloudinary.com/cafebabe/tomcat-0"></center></li></ul><p>在浏览器键入<code>Tomcat</code>地址加端口，即可访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Tomcat&lt;/code&gt;安装后，默认目录是&lt;code&gt;/webapps/ROOT&lt;/code&gt;，我们自己的&lt;code&gt;Web&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://wuyuzhao666.github.io/categories/Linux/"/>
    
    
      <category term="Tomcat#" scheme="http://wuyuzhao666.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>idea配置jvm参数</title>
    <link href="http://wuyuzhao666.github.io/2019/04/12/idea%E9%85%8D%E7%BD%AEjvm%E5%8F%82%E6%95%B0/idea%E9%85%8D%E7%BD%AEjvm%E5%8F%82%E6%95%B0/"/>
    <id>http://wuyuzhao666.github.io/2019/04/12/idea配置jvm参数/idea配置jvm参数/</id>
    <published>2019-04-12T01:41:02.000Z</published>
    <updated>2019-04-12T01:41:02.341Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用JVM配置参数</title>
    <link href="http://wuyuzhao666.github.io/2019/04/08/%E5%B8%B8%E7%94%A8JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/%E5%B8%B8%E7%94%A8JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>http://wuyuzhao666.github.io/2019/04/08/常用JVM配置参数/常用JVM配置参数/</id>
    <published>2019-04-08T00:42:03.000Z</published>
    <updated>2019-04-08T01:19:13.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Trace跟踪参数"><a href="#Trace跟踪参数" class="headerlink" title="Trace跟踪参数"></a>Trace跟踪参数</h2><ul><li><p>-verbose:gc</p><p>-XX:+printGC</p></li></ul><blockquote><p>可以打印GC的简要信息</p></blockquote><ul><li>-XX:+PrintGCDetails</li></ul><blockquote><p>打印GC详细信息</p></blockquote><ul><li>-XX:+PrintGCTimeStamps</li></ul><blockquote><p>打印CG发生的时间戳</p></blockquote><ul><li>-Xloggc:log/gc.log</li></ul><blockquote><p>指定GC log的位置，以文件输出</p><p>帮助开发人员分析问题</p></blockquote><ul><li>-XX:+PrintHeapAtGC</li></ul><blockquote><p>每次一次GC后，都打印堆信息</p></blockquote><ul><li>-XX:+TraceClassLoading</li></ul><blockquote><p>监控类的加载</p></blockquote><h2 id="堆的分配参数"><a href="#堆的分配参数" class="headerlink" title="堆的分配参数"></a>堆的分配参数</h2><ul><li>-Xmx –Xms</li></ul><blockquote><p>指定最大堆和最小堆</p></blockquote><ul><li>-Xmn</li></ul><blockquote><p>设置新生代大小</p></blockquote><ul><li>-XX:NewRatio</li></ul><blockquote><p>新生代（eden+2*s）和老年代（不包含永久区）的比值</p><p>=4 表示 新生代:老年代=1:4，即年轻代占堆的1/5</p></blockquote><ul><li>-XX:SurvivorRatio</li></ul><blockquote><p>设置两个Survivor区和eden的比</p><p>=8表示 两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10</p><p>在HotSpot虚拟机中，默认Eden区与一个Survivor区比例为8：1</p></blockquote><ul><li>-XX:+HeapDumpOnOutOfMemoryError</li></ul><blockquote><p>OOM时导出堆到文件</p></blockquote><ul><li>-XX:+HeapDumpPath</li></ul><blockquote><p>导出OOM的路径</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump</span><br></pre></td></tr></table></figure><ul><li>-XX:OnOutOfMemoryError</li></ul><blockquote><p>在OOM时，执行一个脚本</p><p>“-XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p“</p><p>当程序OOM时，在D:/a.txt中将会生成线程的dump</p><p>可以在OOM时，发送邮件，甚至是重启程序</p></blockquote><h2 id="永久区分配参数"><a href="#永久区分配参数" class="headerlink" title="永久区分配参数"></a>永久区分配参数</h2><ul><li>-XX:PermSize  -XX:MaxPermSize</li></ul><blockquote><p>设置永久区的初始空间和最大空间</p></blockquote><h2 id="栈大小分配"><a href="#栈大小分配" class="headerlink" title="栈大小分配"></a>栈大小分配</h2><ul><li>-Xss</li></ul><blockquote><p>-Xss256k</p><p>通常只有几百K</p><p>决定了函数调用的深度</p><p>每个线程都有独立的栈空间</p><p>局部变量、参数 分配在栈上</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Trace跟踪参数&quot;&gt;&lt;a href=&quot;#Trace跟踪参数&quot; class=&quot;headerlink&quot; title=&quot;Trace跟踪参数&quot;&gt;&lt;/a&gt;Trace跟踪参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-verbose:gc&lt;/p&gt;
&lt;p&gt;-XX:+printGC&lt;/
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM参数" scheme="http://wuyuzhao666.github.io/tags/JVM%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Apache服务器的安装与配置</title>
    <link href="http://wuyuzhao666.github.io/2019/04/07/Linux%E4%B8%8BApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/Linux%E4%B8%8BApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://wuyuzhao666.github.io/2019/04/07/Linux下Apache服务器的安装与配置/Linux下Apache服务器的安装与配置/</id>
    <published>2019-04-07T12:39:17.000Z</published>
    <updated>2019-04-29T09:51:42.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<code>linux</code>中，<code>Apache</code>服务器叫做<code>httpd</code>。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先下载<code>httpd</code>与<code>httpd</code>的依赖软件。</p><ul><li><p>Apache HTTP Server</p><p><a href="http://httpd.apache.org/download.cgi#apache24" target="_blank" rel="noopener">http://httpd.apache.org/download.cgi#apache24</a></p></li><li><p>APR和APR-Util</p><p><a href="http://apr.apache.org/download.cgi" target="_blank" rel="noopener">http://apr.apache.org/download.cgi</a></p></li><li><p>PCRE</p><p><a href="https://sourceforge.net/projects/pcre/files/pcre/" target="_blank" rel="noopener">https://sourceforge.net/projects/pcre/files/pcre/</a></p></li></ul><p>没有<code>gcc/gcc-c++</code>的话，先安装<code>gcc/gcc-c++</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# yum install gcc-c++</span><br></pre></td></tr></table></figure><blockquote><p>基于centos，其余系统相应变化。</p><p>先确定服务器是否联网，若安装过程出现错误，可能是缺某些依赖包，谷歌百度下，会有结果的。</p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf apr-1.6.5.tar.gz</span><br><span class="line">tar -zxf apr-util-1.6.1.tar.gz</span><br><span class="line">tar -zxf pcre-8.38.tar.gz</span><br><span class="line">tar -zxf httpd-2.4.37.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>默认解压到当前目录</p></blockquote><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>直接复制粘贴，修改成刚刚解压的相应目录。</p><ul><li>apr的安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd apr-1.6.5</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/apr-1.6.5</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>apr-util的安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../apr-util-1.6.1</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/apr-util --with-apr=/home/apr-1.6.5/bin/apr-1-config</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>pcre的安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../pcre-8.38</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/pcre-8.38 --with-apr=/home/apr-1.6.5/bin/apr-1-config</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>httpd的安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../httpd-2.4.18</span><br><span class="line"></span><br><span class="line">./configure --prefix=/home/httpd-2.4.37 --with-pcre=/home/pcre-8.38 --with-apr=/home/apr-1.6.5 --with-apr-util=/home/apr-util-1.6.1</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><center><img src="http://res.cloudinary.com/cafebabe/linux-1"></center><p>安装成功。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>想要将<code>httpd</code>作为文件服务器，需要更改一些配置。</p><ul><li>进入<code>httpd</code>的<code>conf</code>文件夹。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/httpd-2.4.37/conf</span><br></pre></td></tr></table></figure><ul><li>打开<code>httpd.conf</code>配置文件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi httpd.conf</span><br></pre></td></tr></table></figure><ul><li>更改端口号</li></ul><center><img src="http://res.cloudinary.com/cafebabe/linux-2"></center><ul><li>更改主机号</li></ul><center><img src="http://res.cloudinary.com/cafebabe/linux-3"></center><ul><li>更改文件目录</li></ul><center><img src="http://res.cloudinary.com/cafebabe/linux-4"></center><ul><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hmaster bin]# ./apachectl start</span><br><span class="line">[root@hmaster bin]# ./apachectl stop</span><br><span class="line">[root@hmaster bin]# ./apachectl restart</span><br></pre></td></tr></table></figure></li></ul><ul><li>检查</li></ul><p>出现此页面，则安装成功。</p><center><img src="http://res.cloudinary.com/cafebabe/linux-5"></center><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>遇到的问题：</p><ul><li><p>启动时遇到的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd: Could not open configuration file /xxx/conf/httpd.conf: No such file or directory</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./apachectl -f /xxx/httpd/conf/httpd.conf -k start</span><br></pre></td></tr></table></figure><p>以<code>httpd.conf</code>配置文件启动。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;linux&lt;/code&gt;中，&lt;code&gt;Apache&lt;/code&gt;服务器叫做&lt;code&gt;httpd&lt;/code&gt;。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://wuyuzhao666.github.io/categories/Linux/"/>
    
    
      <category term="Apache" scheme="http://wuyuzhao666.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://wuyuzhao666.github.io/2019/03/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://wuyuzhao666.github.io/2019/03/29/虚拟机字节码执行引擎/虚拟机字节码执行引擎/</id>
    <published>2019-03-29T06:51:14.000Z</published>
    <updated>2019-03-30T07:14:19.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将<code>Java</code>源文件编译成字节码之后，就可以通过<code>Java</code>虚拟机的核心组件——执行引擎来进行执行。现代<code>JVM</code>在执行<code>Java</code>代码的时候，通常都会将解释执行与编译执行二者结合起来进行。执行过程一般都是输入字节码，解析字节码，输出执行结果。</p><blockquote><p>解释执行：由<code>Java</code>解释器执行，将字节码从头开始进行读取，读取到相应的指令就去执行该指令。</p><p>编译执行：不要与源代码的编译混为一谈。就是将字节码由即时编译器（<code>Just In Time ,JIT</code>）产生本地代码，就是相应的机器码，然后去执行。现代<code>JVM</code>会根据热点代码（经常调用的代码）来生成相应的本地机器码。转换为机器码，就不具有可移植性了，各个平台的机器码各不相同。</p></blockquote><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧，简单来说就是——用于帮助虚拟机执行方法调用与方法执行的数据结构。它是<code>jvm</code>运行时数据区中的虚拟机栈中的栈元素。栈帧本身是一种数据结构，封装了方法的局部变量表、动态连接、方法的返回地址以及操作数栈。在上文中<a href="/2019/03/27/Java字节码（一）：深度分析Class类文件/Java字节码（一）：深度分析Class类文件/">Java字节码（一）：深度分析Class类文件</a>中，我们知道了在<code>Class</code>文件中每个方法的操作数栈深度以及局部变量表都已经在编译期确定了，被写入到<code>Code</code>属性中了。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表是用以存储方法参数、方法内部定义的局部变量以及代表当前对象的<code>this</code>。<code>Slot</code>是虚拟机为局部变量分配内存所使用的最小单位。不超过32位的数据类型占1个<code>Slot</code>，64位的数据类型则使用两个<code>Slot</code>，在编译期，就已经确定好局部变量表的所需的存储空间了。另外，并不是在方法中用到了多少了局部变量，就把这些<code>Slot</code>之和作为<code>max_locals</code>的值，原因是局部变量表中的<code>Slot</code>可以重用，在局部变量表中通过这个变量的偏移量可以得到这个变量的作用域，当代码执行超出一个局部变量的作用域时，这个局部变量所占的<code>Slot</code>就可以被其他局部变量所使用，编译器会根据变量的作用域来分配<code>Slot</code>给各个变量使用，然后计算出<code>max_loacals</code>的大小。</p><center><img src="http://res.cloudinary.com/cafebabe/WORQM5_F3_O_2XM_7I__LY"></center><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈，即是一个先入后出的栈。同局部变量表一样，在编译期，<code>Javac</code>编译器也将所需的操作数栈的深度计算出来放到<code>Code</code>属性中的<code>max_stacks</code>中。当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。</p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在<code>Class</code>文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。</p><h4 id="方法的返回地址"><a href="#方法的返回地址" class="headerlink" title="方法的返回地址"></a>方法的返回地址</h4><p>方法的返回地址就是在栈帧中保存的一些信息，用以在当方法调用完成后，就可以会返回到调用方法处，继续执行代码，有了这个地址，就可以回到这个调用处，继续执行下面的代码。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用<code>PC</code>计数器的值以指向方法调用指令后面的一条指令等。</p><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>方法的调用指的是确定被调用方法的版本，即确定调用哪一个方法。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在程序运行之前，就确定好执行哪个方法，即在在编译期间，就可以确定下来，然后在类加载的解析阶段，就将常量池中，与此方法有关的符号引用转换为直接引用。因此，想要在类加载阶段就完成解析工作，首先这个方法是可以确定唯一的版本的，比如静态方法、私有方法、构造方法、父类方法，称为非虚方法，与之相对应的字节码助记符：</p><ul><li><p><code>invokestatic</code>:调用静态方法</p></li><li><p><code>invokespecial</code>：调用构造方法、私有方法和父类方法</p></li></ul><p>解析一定是一个静态过程，在编译期间就可以确定其要调用哪个方法，在类加载的解析阶段，就可以将涉及的符号引用，即<code>invokestatic</code>和<code>invokespecial</code>指令的参数在常量池中相对应的符号引用转换为直接引用。</p><h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><h5 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h5><p>静态分派，简单来说，可以理解为在编译期间根据静态类型确定方法执行版本的分派过程。静态分派与方法的重载是密切相关的。</p><blockquote><p>静态类型：</p><p><code>Grandpa g1 = new Father();</code><br>以上代码，<code>g1</code>的静态类型是<code>Grandpa</code>，而<code>g1</code>的实际类型（真正指向的类型）是<code>Father</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Grandpa grandpa)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"grandpa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Father father)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father"</span>);</span><br><span class="line">    <span class="comment">//方法的重载，是一种静态行为，在编译期就可以确定</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son son)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest6 myTest6 = <span class="keyword">new</span> MyTest6();</span><br><span class="line">        Grandpa g1 = <span class="keyword">new</span> Father();</span><br><span class="line">        Grandpa g2 = <span class="keyword">new</span> Son();</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        myTest6.test(father);</span><br><span class="line">        myTest6.test(g1);</span><br><span class="line">        myTest6.test(g2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Grandpa</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">father</span><br><span class="line">grandpa</span><br><span class="line">grandpa</span><br></pre></td></tr></table></figure><p>在方法接收者已经确定的前提下，使用哪个重载版本，取决于传入的参数的数量和数据类型。编译器在重载时通过参数的<code>静态类型</code>来确定重载方法的版本。并且<code>静态类型是在编译期</code>可知的，意思是对于重载来说，在编译阶段，就已经确定了要执行的重载方法的版本。</p><blockquote><ul><li>常量池中生成对应重载方法的符号引用（没用到的重载方法版本是不会在常量池中生成符号引用的）。</li><li>对于没有显示静态类型的字面量来说，它的静态类型只能通过语言上的规则来理解和推断。</li></ul></blockquote><h5 id="静态分派与解析的区别"><a href="#静态分派与解析的区别" class="headerlink" title="静态分派与解析的区别"></a>静态分派与解析的区别</h5><p>解析与静态分派不是一个层面上的东西，它们是在不同的层次上去筛选、确定方法的过程。解析针对的是，在类加载的解析阶段，能够确定的唯一方法，针对的是<code>invokestatic</code>和<code>invokespecial</code>。而静态分派则是，在编译阶段方法的接收者确定的情况下，根据参数的静态类型确定重载方法的版本。</p><h5 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h5><p>动态分派，简单来说，可以理解为在运行期间根据实际类型确定方法执行版本的分派过程。针对的是方法的重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Fruit orange = <span class="keyword">new</span> Orange();</span><br><span class="line"></span><br><span class="line">        apple.test();</span><br><span class="line">        orange.test();</span><br><span class="line"></span><br><span class="line">        apple = <span class="keyword">new</span> Orange();</span><br><span class="line">        apple.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fruit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple</span><br><span class="line">Orange</span><br><span class="line">Orange</span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示，方法的确定是通过变量的实际类型来确定的。</p></blockquote><p>来看看这个方法的<code>Code</code>属性。</p><center><img src="http://res.cloudinary.com/cafebabe/1553916781_1"></center><p>可以看出，在编译阶段，生成的字节码文件中<code>invokevirtual</code>指令的参数都是父类<code>Fruit</code>的<code>test</code>方法，但实际在运行时，这几个相同的指令最终执行的目标方法并不相同，这是依赖于<code>invokevirtual</code>的多态查找过程。</p><blockquote><pre><code>动态分派的多态查找过程：1. 找到操作数栈顶的第一个元素所指向的对象的实际类型。2. 如果在这个类型中找到与常量池中符号引用相同的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用。3. 否则，按照继承关系从下往上依次对这个对象类型的父类进行搜索和验证。</code></pre></blockquote><p><code>invokevirtual</code>指令执行的第一步就是在运行期确定方法接收者的实际类型，所以这几次调用<code>invokevirtual</code>指令就将常量池中的类符号引用解析到了不同的直接引用上，这个过程就是<code>Java</code>语言中方法重写的本质。这种在运行期根据实际类型确定方法执行版本的分派过程就叫动态分派。</p><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        animal.test(<span class="number">1</span>);</span><br><span class="line">        cat.test(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"animal str"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat str"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animal int</span><br><span class="line">cat str</span><br></pre></td></tr></table></figure><p>结果不重要，看看<code>Code</code>属性：</p><center><img src="http://res.cloudinary.com/cafebabe/7JFZ9OEA9OU_FHRNLDS_O_5"></center><blockquote><ul><li><p>在编译阶段，编译器的选择过程，也就是静态分派的过程：</p><p>这时候的判断依据有两点：静态类型是<code>Cat</code>还是<code>Animal</code>，以及传入的参数是<code>int</code>还是<code>String</code>，这次选择产生了两条<code>invokevirtual</code>指令，这两条指令分别指向常量池中的<code>Animal.test(int)</code>以及<code>Animal.test(String)</code>。</p></li><li><p>然后到了运行阶段，也就是动态分派过程：</p><p>执行到了<code>invokevitual</code>指令，由于在编译阶段，已经确定好方法的参数，此时就只需确定方法的接收者的实际类型。根据<code>invokevirtual</code>的多态查找过程，找出正确的重写方法去执行。</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;将&lt;code&gt;Java&lt;/code&gt;源文件编译成字节码之后，就可以通过&lt;code&gt;Java&lt;/code&gt;虚拟机的核心组件——执行引擎来进行执
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机字节码执行引擎" scheme="http://wuyuzhao666.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码（一）：深度分析Class类文件</title>
    <link href="http://wuyuzhao666.github.io/2019/03/27/Java%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90Class%E7%B1%BB%E6%96%87%E4%BB%B6/Java%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90Class%E7%B1%BB%E6%96%87%E4%BB%B6/"/>
    <id>http://wuyuzhao666.github.io/2019/03/27/Java字节码（一）：深度分析Class类文件/Java字节码（一）：深度分析Class类文件/</id>
    <published>2019-03-27T07:58:04.000Z</published>
    <updated>2019-03-27T13:46:56.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们知道，<code>java</code>是一个跟平台无关性的编程语言，而平台无关性的基础就是虚拟机与字节码存储格式。<code>Java</code>虚拟机不和包括<code>java</code>语言在内的任何语言绑定，它只认<code>Class</code>文件（<code>kotlin</code>、<code>scala</code>等皆可在<code>jvm</code>上运行）。<code>Class</code>文件中包含了一个<code>Java</code>程序的指令集和符号集以及其他信息，编译器严格按照规范来将<code>Java</code>程序编译为字节码。在这儿，我们分析下<code>Class</code>文件的数据结构。</p><h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p><code>Class</code>文件是以8位字节为基础的二进制流文件，其中没有间隔，在文件中只保留了必要的数据，节省了大量的空间。在<code>Class</code>字节码中有两种数据类型：</p><ul><li>字节数据直接量：这是基本的数据类型。共细分为<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>四种，分别代表连续的<code>1</code>个字节、<code>4</code>个字节、<code>8</code>个字节组成的整体数据。</li><li>表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。</li></ul><p>如下图所示，<code>Class</code>文件中字节码按一下顺序进行排列。</p><center><img src="http://res.cloudinary.com/cafebabe/class-2"></center><p>我们通过最简单的一个程序，来示例讲解<code>Class</code>文件结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用16进制工具(<code>winHex</code>)打开<code>MyTest1.class</code>文件，16进制字节码中，一个数字或字母占4位，两个数字或字母代表一个字节。</p><center><img src="http://res.cloudinary.com/cafebabe/class-1"></center><p>使用<code>javap -verbose</code>命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的构造方法、类中的方法信息、类变量与成员变量等信息。</p><center><img src="http://res.cloudinary.com/cafebabe/class-4"></center><h4 id="魔数-4个字节"><a href="#魔数-4个字节" class="headerlink" title="魔数(4个字节)"></a>魔数(4个字节)</h4><p>所有的<code>.class</code>字节码文件的前4个字节都是魔数，魔数值是一固定值：<code>0xCAFEBABE</code>。 是用以<code>Java</code>虚拟机确定<code>class</code>文件的标志。很多文件格式都采用了魔数来进行文件的身份标识，比如<code>jpg</code>。选择在文件内容头部使用魔数而不用扩展名来进行文件的身份标识，主要是考虑了安全问题，因为扩展名易被修改。而魔数则可以由文件格式的制定者随意的指定，只要选择的魔数没有被广泛采用且不与其他魔数重复引起混淆就行。</p><h4 id="版本号（2-2个字节）"><a href="#版本号（2-2个字节）" class="headerlink" title="版本号（2+2个字节）"></a>版本号（2+2个字节）</h4><p>.魔数之后的4个字节为版本信息，前两个字节表示<code>minor version</code>（次版本号），后两个字节表示<code>major version</code>（主版本号）。这里<code>00 00 00 34</code>，换算成十进制，表示次版本号为<code>0</code>，主版本号<code>52</code>。表示<code>java</code>版本<code>1.8.0</code>，<code>1.8</code>表示主版本号，<code>0</code>表示次版本号。可以使用<code>java -version</code>查看。<code>JDK</code>是向下兼容的，高版本的<code>JDK</code>能运行低于此版本的<code>Class</code>文件，低版本的<code>JDK</code>无法运行高于它本身的<code>Class</code>文件，即使文件格式未出错，虚拟机也拒绝执行高于其版本的<code>Class</code>文件。若进行运行，会报错<code>java.lang.UnsupportedClassVersionError</code>。</p><h4 id="常量池（2-n个字节）"><a href="#常量池（2-n个字节）" class="headerlink" title="常量池（2+n个字节）"></a>常量池（2+n个字节）</h4><p>常量池（constant pool）：紧接着主版本号之后的就是常量池入口。一个<code>Java</code>类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是<code>Class</code>文件的资源仓库，比如说<code>Java</code>类中定义的方法与变量信息，都是存储在常量池中。</p><p>常量池中主要存储两类常量：字面量和符号引用。</p><ul><li>字面量如文本字符串，<code>Java</code>中声明为<code>final</code>的常量值等。</li><li>符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符。</li></ul><h5 id="常量池的总体结构"><a href="#常量池的总体结构" class="headerlink" title="常量池的总体结构"></a>常量池的总体结构</h5><p><code>Java</code>类所对应的常量池主要由常量池与常量池数组（常量表）这两部分共同构成。</p><ul><li><p>常量池数量紧跟在主版本号后面，占据<code>2</code>个字节</p></li><li><p>常量池数组则紧跟在常量池数量之后。</p><p>常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同，这些元素是被称之为表的数据结构；但是，每一种元素的第一个数据都是一个<code>u1</code>类型，该字节是个标志位，占据一个字节。<code>JVM</code>在解析常量池时，会根据这个<code>u1</code>类型来获取元素的具体类型。</p><blockquote><p>值得注意的是，常量池数组中元素的个数 = 常量池数量 - 1 （其中0位暂时不使用），根本原因在于，索引0也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应<code>null</code>值；所以，常量池的索引从1而非0开始。</p></blockquote></li></ul><center><img src="http://res.cloudinary.com/cafebabe/class-3"></center><h5 id="常量池中的描述信息"><a href="#常量池中的描述信息" class="headerlink" title="常量池中的描述信息"></a>常量池中的描述信息</h5><ul><li>在<code>JVM</code>规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的<code>void</code>类型都用一个大写字符来表示，对象类型则使用字符<code>L</code>加对象的全限定名称来表示，为了压缩字节码文件的体积，对于基本数据类型，<code>JVM</code>都只使用一个大写字母来表示，如：<code>B - byte</code>, <code>C - char</code> ,<code>D - double</code> , <code>F - float</code>, <code>I - long</code> , <code>s - short</code>,<code>Z - boolean</code> ,<code>V - void</code>,<code>L - 对象类型</code>，如<code>Ljava/lang/String</code>;</li><li>对于数组类型来说，每一个维度都使用一个<code>[</code>来表示，如<code>int[]</code>被记录为<code>[I,String</code>,<code>String[]</code>[][]被记录为<code>[[Ljava/lang/String</code>;</li><li>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组<code>()</code>之内，如方法:<code>String test(int a,String b)</code>的描述为：<br><code>（I，Ljava/lang/String）Ljava/lang/String;</code></li></ul><h5 id="示例代码的常量池"><a href="#示例代码的常量池" class="headerlink" title="示例代码的常量池"></a>示例代码的常量池</h5><p>​    常量池数量：</p><ol><li><p>第9、10个字节代表着常量池数量00 18，即24-1=23。</p><p>常量池数组：</p></li><li><p>第11个字节是<code>0A</code>（tag值）= 10 ，为<code>CONSTANT_Meothdref_info</code>，这个类型有两个<code>index</code>值，占4个字节<code>00 04 00 14</code>，即为常量池中第4个元素，和第20个元素。</p><blockquote><p> java/lang/Object.”<init>“:()V</init></p><p>表示无参数列表的返回值为void的<init>方法，即虚拟机创建的构造方法。</init></p></blockquote></li><li><p>第16个字节为09 = 9 ，为<code>CONSTANT_Fieldref_info</code>，后四个字节为两个索引<code>00 03 00 15</code><br>即第3个元素，第21个元素。</p><blockquote><p>bytecode/MyTest1.a:I<br>表示<code>MyTest1</code>类下的a属性的值为int类型</p></blockquote></li><li><p>第21个字节为07，为<code>CONSTANT_Class_info</code>，后2个字节为指向全限定名常量项的索引，指向22 </p><blockquote><p>bytecode/MyTest1</p><p>表示此类的全限定名</p></blockquote></li><li><p>第24字节为07，00 17指向#23。</p><blockquote><p>java/lang/Object<br>表示父类的全限定名</p></blockquote></li><li><p>第27字节为01，为<code>CONSTANT_utf8_info</code>，后2位字节为<code>UTF-8</code>编码的字符串长度<code>length</code> 00 01，表示后面有一个字节来表示这个字符，即为61 = <code>a</code></p><blockquote><p>后面相同的类型，就简写了。</p></blockquote></li><li><p>第31字节为01，00 01，字符串为49 = <code>I</code>         </p></li><li><p>第35字节为01，00 06，字符串<code>3C 69 6E 69 74 3E</code>，表示为<code>&lt;init&gt;</code>     </p></li><li><p>第43字节为01 ，00 03，28 29 56，表示为<code>()V</code></p></li><li><p>第50字节为01，00 04，43 6F 64 65，表示为<code>Code</code>     </p></li><li><p>第57字节为01，00 0F，表示为<code>LineNumberTable</code></p></li><li><p>第75字节01 ，00 12，表示为<code>LocalVariableTable</code></p></li><li><p>第95字节01， 00 04 ，<code>this</code></p></li><li><p>第83字节01，00 12，<code>Lbytecode/MyTest1;</code></p></li><li><p>第109字节01，00 04，<code>getA</code>    </p></li><li><p>第131字节01，00 03，<code>()I</code>         </p></li><li><p>第136字节01，00 04，<code>setA</code>     </p></li><li><p>第143字节01， 00 04，<code>(I)V</code></p></li><li><p>第151字节01，00 01，<code>SourceFile</code></p></li></ol><ol start="20"><li><p>第163字节01，00 0C，<code>MyTest1.java</code>    </p></li><li><p>第179字节0C,为<code>CONSTANT_NameAndType_info</code>，后四个字节指向方法名称#7；方法描述#8</p><blockquote><p>“<init>“:()V</init></p></blockquote></li></ol><ol start="22"><li><p>第184字节0C,为<code>CONSTANT_NameAndType_info</code>,后四个字节指向字段名称#5；字段描述#6</p><blockquote><p>a:I</p></blockquote></li><li><p>第189字节01，00 10，<code>bytecode/MyTest1</code>    </p></li><li><p>第207字节01，00 10，<code>java/lang/Object</code></p></li></ol><h4 id="类的访问权限（2个字节）"><a href="#类的访问权限（2个字节）" class="headerlink" title="类的访问权限（2个字节）"></a>类的访问权限（2个字节）</h4><p>接下来是类的访问权限<code>access_flag</code>，第227、228字节00 21：是<code>0x0020</code>和<code>0x0001</code>的并集，表示<code>ACC_PUBLIC</code>与<code>ACC_SUPER</code>。</p><center><img src="http://res.cloudinary.com/cafebabe/class-5"></center><h4 id="类名（2个字节）"><a href="#类名（2个字节）" class="headerlink" title="类名（2个字节）"></a>类名（2个字节）</h4><p>第229、230字节00 03为类名，是一个引用值，表示常量池中第三个常量。当前类的全限定名。</p><h4 id="父类名（2个字节）"><a href="#父类名（2个字节）" class="headerlink" title="父类名（2个字节）"></a>父类名（2个字节）</h4><p>第231、232字节00 04为父类名，是一个引用值，表示常量池中第四个常量。当前类的父类全限定名。</p><h4 id="接口（2-n个字节）"><a href="#接口（2-n个字节）" class="headerlink" title="接口（2+n个字节）"></a>接口（2+n个字节）</h4><p>第233、234字节00 00为接口数，接口数为0，后面的接口名就不会出现了。</p><h4 id="域（2-n个字节）"><a href="#域（2-n个字节）" class="headerlink" title="域（2+n个字节）"></a>域（2+n个字节）</h4><h5 id="域的个数"><a href="#域的个数" class="headerlink" title="域的个数"></a>域的个数</h5><p>第235、236字节00 01为成员变量数，为1个。</p><h5 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h5><p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别的变量以及实例变量，但是不包括方法内部声明的局部变量，下图为字段表的结构。</p><center><img src="http://res.cloudinary.com/cafebabe/class-6"></center><blockquote><p>本例中只有一个字段。</p></blockquote><ol><li>第237、238字节00 02为这个成员变量的权限访问符，表示<code>privat</code>。</li><li>第239、240字节00 05为这个成员变量的名称描述符，指向常量池中的#5 =<code>a</code>。</li><li>第241、242字节00 06为这个成员变量的类型描述符，指向常量池中的#6 =<code>I</code>。</li><li>第243、244字节00 00为附加属性个数，为0，则附加属性表就不会出现。附加属性是有些编译器在编译阶段添加的值。</li></ol><h4 id="方法（2-n个字节）"><a href="#方法（2-n个字节）" class="headerlink" title="方法（2+n个字节）"></a>方法（2+n个字节）</h4><h5 id="方法个数"><a href="#方法个数" class="headerlink" title="方法个数"></a>方法个数</h5><p>第245、246字节00 03为方法数，共3个方法。</p><h5 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h5><p>方法表描述了一个方法的信息。</p><center><img src="http://res.cloudinary.com/cafebabe/class-7"></center><p>属性表集合描述了这个方法的相关属性，执行码、异常表等，<code>JVM</code>预定义了部分属性，但是编译器自己也可以实现自己的属性写入<code>class</code>文件里，供运行时使用。</p><p>不用的属性通过<code>attribute_name_index</code>来区分。</p><center><img src="http://res.cloudinary.com/cafebabe/class-8"></center><h6 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h6><ol><li><p>第247、248字节00 01为权限访问符，表示<code>public</code>。</p></li><li><p>第249、250字节00 07为这个方法的名称描述符，指向常量池中的#7 = <code>&lt;init&gt;</code></p></li><li><p>第251、252字节00 08为这个方法的类型描述符，指向常量池中的#8 = <code>()V</code></p></li><li><p>第253、254字节00 01为附加属性个数。这些属性用以描述方法，由<code>Java</code>虚拟机根据方法的执行代码编译时计算出来的。</p></li><li><p>属性信息<code>attribute_info</code>:</p><blockquote><p><code>Code attribute</code>的作用是保存改方法的结构，如下图。</p><center><img src="http://res.cloudinary.com/cafebabe/class-9"></center><ul><li><code>attribute_length</code>表示<code>attribute</code>所包含的字节数，不包含<code>attribute_name_index</code>和<code>attribute_length</code>字段。</li><li><code>max_stack</code>表示这个方法运行的任何时刻所能达到的操作数栈的最大深度。</li><li><code>max_locals</code>表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量。</li><li>code_length表示该方法所包含的字节码的字节数以及具体的指令码。</li><li>具体字节码即是该方法被调用时，虚拟机所执行的字节码。</li><li><code>exception_table</code>，这里存放的是处理异常的信息。</li><li>每个<code>exception_table</code>表现由<code>start_pc</code>，<code>end_pc</code>，<code>hander_pc</code>，<code>catch_type</code>组成。</li></ul></blockquote><ol><li><p>第255、256字节00 09为属性值的索引，#9 为<code>Code</code>，表示执行代码。</p></li><li><p>第257、258、259、260字节00 00 00 38为属性长度，为56字节。</p></li><li><p>第261、262字节00 02为操作数栈的最大深度，栈深度为2。</p></li><li><p>第263、264字节00 01为局部变量个数。</p></li><li><p>第265、266、267、268字节00 00 00 0A为这个方法包含的字节数与字节码，一共占10个字节，代表这个方法真正执行的内容（也就是助记符，在字节码中只是一些16进制的符号，转换为助记符，帮助我们记忆）。</p><ol><li><p>第269字节2A，对应助记符<code>aload_0</code>，从局部变量表中位于0<code>slot</code>中的变量推到操作数栈中去。</p></li><li><p>对应助记符<code>invokespecial</code>，调用父类的方法。</p><ol><li>第271、272字节00 01代表这个助记符的参数 ，指向常量池#1，<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>，即代表调用<code>Object</code>类的这个方法，即父类的构造方法。</li></ol></li><li><p>第273字节2A，对应助记符<code>aload_0</code>。</p></li><li><p>第274字节04 ，对应助记符<code>iconst_1</code>，将<code>int</code>类型的数<code>1</code>推送到操作数栈顶。</p></li><li><p>第275字节B5 ，对应助记符<code>putfield</code>。</p><ol><li>第276、277字节00 02代表这个助记符的参数，指向常量池#2， <code>bytecode/MyTest1.a:I</code>，也就是说将刚刚推到操作数栈顶的<code>1</code>赋予<code>MyTest1</code>中的<code>a</code>。</li></ol></li><li><p>第278字节B1，对应助记符<code>return</code>，返回<code>void</code>。</p></li></ol></li><li><p>第279、280字节00 00，异常表长度为0，异常表就不会出现了。</p></li><li><p>第281、282字节00 02，表示附加属性个数。</p><blockquote><p>首先是<code>LineNumTable</code>，行号信息，通过这个信息，可以确定，代码的所在的行数。</p><center><img src="http://res.cloudinary.com/cafebabe/class-10"></center></blockquote><ol><li><p>第283、284字节00 0A，代表附加属性索引，指向常量池#10，<code>LineNumberTable</code></p></li><li><p>第285、286、287、288字节00 00 00 0A，代表这个附加属性的长度。</p></li><li><p>第289、290字节00 02，代表有两个映射。</p></li><li><p>第291、292字节00 00，</p></li><li><p>第293、294字节00 0F，表示<code>code</code>数组中偏移量为0的，映射到第10行，在第10行，编译器生成了一个构造方法。</p></li><li><p>第295、296字节00 04，</p></li><li><p>第297、298字节00 11，表示code数组中偏移量为4的，映射到第17行，</p><pre><code>然后是LocalVariableTable，局部变量表。</code></pre></li><li><p>第299、300字节00 0B，代表附加属性索引，指向常量池#11，<code>LocalVariableTable</code></p></li><li><p>第301、302、303、304字节00 00 00 0C代表这个附加属性的长度。</p></li><li><p>第305、306字节00 01 ，代表只有一个变量。</p></li><li><p>第307、308字节00 00，代表局部变量从0开始。</p></li><li><p>第309、310字节00 0A，代表局部变量长度。</p></li></ol><blockquote><p>11和12决定了局部变量的作用范围是从哪一行到哪一行。</p></blockquote><ol start="13"><li><p>第311字节00，代表局部变量索引。</p></li><li><p>第312字节0C，代表常量池中的#10，<code>this</code>，代表当前对象。</p></li><li><p>第313、314字节00 0D，表示词局部变量的描述，代表常量池中的#13， <code>Lbytecode/MyTest1;</code></p></li><li><p>第315、316字节00 00，做校验检查的。</p></li></ol><blockquote><p>在Java中，每个方法都可以访问this，对于非静态方法来说，至少有一个局部变量传入方法，即this。</p></blockquote><p>​      </p></li></ol></li></ol><h6 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h6><ol><li>第317、318字节00 01为权限访问符，表示<code>public</code>。</li><li>第319、320字节00 0E为这个方法的名称描述符，指向常量池中的#14 = <code>getA</code>。</li><li>第321、322字节00 0F为这个方法的类型描述符，指向常量池中的#15 =<code>()I</code>。</li><li>第323、324字节00 01为附加属性个数。这些属性用以描述方法，由<code>Java</code>虚拟机根据方法的执行代码编译时计算出来的。</li><li><p>属性信息<code>attribute_info</code>:</p><ol><li><p>第325、326字节00 09为属性值的索引，#9 为Code，表示执行代码</p></li><li><p>第327、328、329、330字节00 00 00 2F为属性长度</p></li><li><p>第331、332字节00 01为操作数栈的最大深度</p></li><li><p>第333、334字节00 01为局部变量表最大长度</p></li><li><p>第335、336、337、338字节00 00 00 05为这个方法包含的字节数与字节码，一共占5个字节，代表这个方法真正执行的内容（助记符，在字节码中只是一些16进制的符号，转换为助记符，帮助我们记忆</p><ol><li><p>第339字节2A，对应助记符aload_0，</p></li><li><p>第340字节B4，对应助记符getfiled，调用父类的方法</p></li><li><p>第341、342字节00 02代表这个助记符的参数 ，指向常量池#2， // bytecode/MyTest1.a:I<br>表示从对象中获取字段</p></li><li><p>第343字节AC，对应助记符ireturn，表示返回一个int</p></li><li><p>第344、345字节00 00，异常表长度为0，异常表就不会出现了</p></li><li><p>第346、347字节00 02，表示附加属性个数:</p><blockquote><p>首先是LineNumTable，行号信息</p></blockquote><ol><li><p>第348、349字节00 0A，代表附加属性索引，指向常量池#10，LineNumberTable</p></li><li><p>第350、351、352、353字节00 00 00 06，代表这个附加属性的长度</p></li><li><p>第353、354字节00 01，代表有1个映射</p></li><li><p>第355、356字节00 00，</p></li><li><p>第357、358字节14 00，</p></li><li><p>表示code数组中偏移量为0的，映射到第20行，在第20行，对应return a；</p></li></ol><blockquote><p>然后是LocalVariableTable，局部变量表</p></blockquote><ol><li>第359、360字节00 0B，代表附加属性索引，指向常量池#11，LocalVariableTable</li><li>第361、362、363、364字节00 00 00 0C代表这个附加属性的长度</li><li>第365、366字节00 01 ，代表只有一个变量</li><li>第367、368字节00 00，代表局部变量从0开始</li><li>第369、370字节00 05，代表局部变量长度</li><li>第371字节00，代表局部变量索引</li><li>第372字节0C，代表常量池中的#10，this，代表当前对象</li><li>第373、374字节00 0D，表示词局部变量的描述，代表常量池中的#13， Lbytecode/MyTest1;</li><li>第376、377字节00 00，做校验检查的</li></ol></li></ol></li></ol></li></ol><h6 id="NO-3"><a href="#NO-3" class="headerlink" title="NO.3"></a>NO.3</h6><p>第三个方法就不再叙述了，与第二个方法差不多。</p><blockquote><p>从上文看出，当一个<code>Java</code>程序中没有构造方法时，编译器会生成一个<code>&lt;init&gt;</code>方法，即构造方法。且非静态成员变量赋值是在构造方法中完成的。若有多个构造方法，每个构造方法都会完成非静态成员变量赋值。</p></blockquote><h4 id="字节属性"><a href="#字节属性" class="headerlink" title="字节属性"></a>字节属性</h4><ol><li>第456、457字节00 01，只有一个属性。</li><li>第458、459字节00 12，指向#18 ，<code>SourceFile</code>。</li><li>第460、461、462、463字节00 00 00 02，表示属性长度，占两个字节。</li><li>第464、465字节00 13，表示#13，<code>MyTest1.java</code> 。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们知道，&lt;code&gt;java&lt;/code&gt;是一个跟平台无关性的编程语言，而平台无关性的基础就是虚拟机与字节码存储格式。&lt;code&gt;Java
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java字节码" scheme="http://wuyuzhao666.github.io/tags/Java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（七）：线程上下文类加载器</title>
    <link href="http://wuyuzhao666.github.io/2019/03/21/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://wuyuzhao666.github.io/2019/03/21/类加载机制（七）：线程上下文类加载器/类加载机制（七）：线程上下文类加载器/</id>
    <published>2019-03-21T12:14:06.000Z</published>
    <updated>2019-03-22T02:59:08.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双亲委托机制的破坏"><a href="#双亲委托机制的破坏" class="headerlink" title="双亲委托机制的破坏"></a>双亲委托机制的破坏</h2><p>我们知道，<code>class</code>文件的加载是按照双亲委托机制完成的，这个机制解决了各个类加载器的基础类的统一问题，因为上层类加载器加载的类对下层加载的类是可见的，所以这些基础类可以被<code>Java</code>程序所调用，但是如果这些基础类需要调用用户所写的类呢，可下层类加载器加载的类不是对上层类加载器加载的类是透明的吗？这种情况不是不可能的，比如<code>JDBC</code>，它位于<code>rt.jar</code>包下，是由启动类加载器加载，而它却需要<code>classPath</code>下的接口提供者（Service Provider Interface）的代码，但是启动类不可能去加载这些代码，那怎么办呢？</p><blockquote><p><code>SPI(Service Provider Interface)</code>：<br>只提供了接口的声明，具体实现由厂商完成。某些<code>SPI</code>需要调用由厂商实现并部署在<code>classPath</code>下的接口实现代码。这些接口由启动类加载器去加载，但启动类加载器不认识<code>classPath</code>下的代码。</p></blockquote><p>这时候就需要对双亲委托机制进行“破坏”了，<code>Java</code>设计者设计了一种叫做“线程上下文类加载器”的机制，当这些接口需要实现的代码时，就去使用这个线程上下文类加载器完成这些接口实现代码的加载。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>线程上下文类加载器<code>contextClassLoader</code>，其实，我们在分析<code>Launcher</code>类的源码时，已经遇到过了:</p><blockquote><p><code>Thread.currentThread().setContextClassLoader(this.loader);</code></p></blockquote><p>在<code>Launcher</code>类的构造方法中，执行了这条语句，并将系统类加载器传进去，我们跟着去看看<code>Thread</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ClassLoader contextClassLoader;</span><br></pre></td></tr></table></figure><blockquote><p>内部维护了一个类加载器，也就是线程上下文类加载器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br></pre></td></tr></table></figure><p>在<code>Thread</code>的<code>init</code>方法中，线程继承其父线程的上下文类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"setContextClassLoader"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>Thread</code>中，可以设置线程类加载器，也就是说，若如果没有通过<code>setContextClassLoader</code>进行设置的话，线程将继承其父线程的上下文类加载器。前面说过，在<code>Launcher</code>类中设置了线程上下文类加载为系统类加载器，即在<code>Java</code>程序中未设置线程上下文类加载器的话，线程上下文类加载器就为系统类加载器。</p><h2 id="深入理解线程上下文类加载器"><a href="#深入理解线程上下文类加载器" class="headerlink" title="深入理解线程上下文类加载器"></a>深入理解线程上下文类加载器</h2><h4 id="线程上下文类加载器的一般使用模式"><a href="#线程上下文类加载器的一般使用模式" class="headerlink" title="线程上下文类加载器的一般使用模式"></a>线程上下文类加载器的一般使用模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(targetccl);</span><br><span class="line">doMethod();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程上下文类加载器的一般使用模式（获取-使用-还原）</p><p>在<code>doMethod()</code>里面调用了<code>Thread.currentThread().setContextClassLoader()</code>来获取当前线程的上下文类加载器做某些事情。</p></blockquote><h4 id="ServiceLoader类"><a href="#ServiceLoader类" class="headerlink" title="ServiceLoader类"></a>ServiceLoader类</h4><p>在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于<code>SPI</code>来说。有些接口是<code>Java</code>核心库所提供的，而<code>Java</code>核心库是由启动类加载器来加载的，而这些接口的实现却是来自于不同的<code>jar</code>包（由各独立厂商实现），<code>Java</code>的启动类加载器是不会加载其他来源的<code>jar</code>包，这样就导致一些接口由启动类加载加载，实现由其他加载器加载，传统的双亲委托机制就会无法满足<code>SPI</code>的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载 。就比如<code>JDBC</code>驱动，如下图所示。</p><center><img src="http://res.cloudinary.com/cafebabe/JDBC.png"></center><p>首先，在<code>pom</code>文件中添加了关于<code>MySql</code>的依赖，我们通过代码找到项目中的驱动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过ServiceLoader去加载驱动</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = drivers.iterator();</span><br><span class="line">        <span class="comment">//打印出每个驱动以及驱动的类加载器</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Driver next = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver:"</span> + next.getClass());</span><br><span class="line">            System.out.println(<span class="string">"loader:"</span> + next.getClass().getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印出当前线程上下文类加载器</span></span><br><span class="line">        System.out.println(<span class="string">"当前线程上下文类加载器:"</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        <span class="comment">//打印出ServiceLoader的类加载器</span></span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader的类加载器:"</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span></span></span><br><span class="line">loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-------------</span><br><span class="line">driver:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">fabric</span>.<span class="title">jdbc</span>.<span class="title">FabricMySQLDriver</span></span></span><br><span class="line">loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-------------</span><br><span class="line">当前线程上下文类加载器:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">ServiceLoader的类加载器:<span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>从输出结果，我们可以看到，<code>MySql</code>的两个驱动都是由系统类加载器所加载的，按常理来说，这些驱动位于<code>classPath</code>下，也该由系统类记载器去加载；前面也说了，当前线程上下文类加载器默认是被设置为系统类加载器；而<code>ServiceLoader</code>位于<code>java.util</code>下，属于核心类库，是由启动类加载器加载的。</p></blockquote><p><code>ServceLoader</code>是对加载驱动很重要的一个类，那它是如何找到这些驱动的呢？</p><h5 id="详解ServiceLoader"><a href="#详解ServiceLoader" class="headerlink" title="详解ServiceLoader"></a>详解ServiceLoader</h5><p><code>ServiceLoader</code>是从<code>JDK1.6</code>才开始出现的，它的作用就是定位加载这些服务的具体实现。从<code>JavaDoc</code>中，我们可以看出<code>ServiceLoader</code>是从服务实现的<code>jar</code>包中的资源目录<code>META-INF/services</code>下去读取驱动名的，并且要求包含这些驱动的文件名必须是服务类型的完全限定的二进制名字，且文件中包含的也是服务实现类的完全限定二进制名，如下图所示。</p><center><img src="http://res.cloudinary.com/cafebabe/mysql-1.png"></center><p><code>META-INF/services</code>下的<code>java.sql.Driver</code>文件里的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure><h5 id="ServiceLoader源码"><a href="#ServiceLoader源码" class="headerlink" title="ServiceLoader源码"></a>ServiceLoader源码</h5><h6 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h6><p>首先，看看<code>ServiceLoader</code>类内部维护的重要字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>直接将资源目录<code>META-INF/services/</code>写死在类中，因为这个资源目录是定好了的，写死也无所谓的。</p><p>第二个字段是用做缓存的，<code>ServiceLoader</code>维护到目前为止加载的服务<code>SPI</code>的缓存</p></blockquote><h6 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h6><p>然后，从<code>load</code>方法说起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">       <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>将服务类型与当前系统类加载器传给另一个<code>load</code>方法。</p></blockquote><p>这里为什么要获取线程上下文类加载器呢？分析一下：<code>ServiceLoader</code>是在普通的<code>Java</code>程序中被引用到的，我们知道，在一个类<code>X</code>中引用另一个类<code>Y</code>，是使用<code>X</code>的类加载器去尝试加载类<code>Y</code>。</p><ul><li><p>系统类加载器会去尝试加载<code>ServiceLoader</code></p></li><li><p>最终启动类加载器将其加载</p></li><li>在<code>ServiceLoader</code>中引用到的类，会由启动类加载器去加载</li><li>但启动类加载器是无法加载到<code>classPath</code>下的类的，所以就通过线程上下文类加载器去加载</li></ul><h6 id="NO-3"><a href="#NO-3" class="headerlink" title="NO.3"></a>NO.3</h6><p>接着，调用私有的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">       service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">       <span class="comment">//要是传进来的线程类加载器为空，就将cl设置为系统类加载器</span></span><br><span class="line">       loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">       acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//调用reload</span></span><br><span class="line">       reload();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将上文提到的缓存清空</span></span><br><span class="line">       providers.clear();</span><br><span class="line">    <span class="comment">//使用一个内部类进行懒加载</span></span><br><span class="line">       lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ServiceLoader</code>内部加载这些服务实现类，是通过按需加载的方式。</p></blockquote><h6 id="NO-4"><a href="#NO-4" class="headerlink" title="NO.4"></a>NO.4</h6><p>只贴出这个内部类<code>LazyIterator</code>的主要代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个内部类内部最重要的两个方法，<code>hasNextService</code>判断是否还有下一个服务实现类，<code>nextService</code>去加载服务实现类。</p></blockquote><h5 id="改变线程类加载器"><a href="#改变线程类加载器" class="headerlink" title="改变线程类加载器"></a>改变线程类加载器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   Thread.currentThread().setContextClassLoader(MyTest17.class.getClassLoader().getParent());</span><br><span class="line">        ServiceLoader&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = drivers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Driver next = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver:"</span> + next.getClass());</span><br><span class="line">            System.out.println(<span class="string">"loader:"</span> + next.getClass().getClassLoader());</span><br><span class="line">            System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前线程上下文类加载器:"</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader的类加载器:"</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前线程上下文类加载器:sun.misc.Launcher$ExtClassLoader@<span class="number">1540e19</span>d</span><br><span class="line">ServiceLoader的类加载器:<span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到，我们将线程类加载器设置为扩展类加载器后，确实是无法将<code>classPath</code>下的服务实现类加载成功的。</p></blockquote><p>我们将线程类加载器设置为我们的自定义类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().setContextClassLoader(<span class="keyword">new</span> MyClassLoader(<span class="string">"loader"</span>));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driver:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span></span></span><br><span class="line">loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-------------</span><br><span class="line">driver:<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">fabric</span>.<span class="title">jdbc</span>.<span class="title">FabricMySQLDriver</span></span></span><br><span class="line">loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">-------------</span><br><span class="line">当前线程上下文类加载器:classLoader.MyClassLoader@<span class="number">6</span>d6f6e28</span><br><span class="line">ServiceLoader的类加载器:<span class="keyword">null</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双亲委托机制的破坏&quot;&gt;&lt;a href=&quot;#双亲委托机制的破坏&quot; class=&quot;headerlink&quot; title=&quot;双亲委托机制的破坏&quot;&gt;&lt;/a&gt;双亲委托机制的破坏&lt;/h2&gt;&lt;p&gt;我们知道，&lt;code&gt;class&lt;/code&gt;文件的加载是按照双亲委托机制完成的，这
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="线程上下文类加载器" scheme="http://wuyuzhao666.github.io/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（六）：getSystemClassLoader与Launcher</title>
    <link href="http://wuyuzhao666.github.io/2019/03/19/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E6%9E%90Launcher%E7%B1%BB/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E6%9E%90Launcher%E7%B1%BB/"/>
    <id>http://wuyuzhao666.github.io/2019/03/19/类加载机制（六）：解析Launcher类/类加载机制（六）：解析Launcher类/</id>
    <published>2019-03-19T08:09:38.000Z</published>
    <updated>2019-03-20T01:13:49.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="getSystemClassLoader"><a href="#getSystemClassLoader" class="headerlink" title="getSystemClassLoader"></a>getSystemClassLoader</h2><p>在前文<a href="/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/">类加载机制（四）：解析ClassLoader</a>，我们分析了<code>ClassLoader</code>类的基本源码，了解了一个<code>class</code>文件是如何被加载到内存中的，也知道了<code>Java</code>应用默认是由系统类加载器加载的，那系统类加载器是由谁加载的、是如何加载的？我们通过贯穿<code>ClassLoader</code>类的一个静态方法<code>getSystemClassLoader</code>来对这些过程进行分析。</p><h4 id="内部维护的字段"><a href="#内部维护的字段" class="headerlink" title="内部维护的字段"></a>内部维护的字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The class loader for the system</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set to true once the system class loader has been set</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sclSet;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>ClassLoader</code>内部维护了两个与加载系统类加载器相关的静态变量，从注释中我们可以看出<code>scl</code>就是用来接收系统类加载器的，而<code>sclSet</code>则是一个布尔值，用来判断<code>scl</code>是否为空的，关于系统类加载器基本都是操作这两个值的。</p></blockquote><h4 id="getSystemClassLoader-1"><a href="#getSystemClassLoader-1" class="headerlink" title="getSystemClassLoader"></a>getSystemClassLoader</h4><p>先来看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用<code>initSystemClassLoader()</code>，并且做了一些安全检查，直接返回系统类加载器<code>scl</code>。</p></blockquote><h4 id="initSystemClassLoader"><a href="#initSystemClassLoader" class="headerlink" title="initSystemClassLoader"></a>initSystemClassLoader</h4><p>通过这个方法来初始化系统类加载器，只贴了主要代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若sclSet为真，则代表系统类加载已经被加载</span></span><br><span class="line">     <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">         <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">         <span class="comment">//创建一个Launcher，后文会讲</span></span><br><span class="line">         sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">         <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//通过Launcher类，获取系统类加载器</span></span><br><span class="line">             scl = l.getClassLoader();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//判断是否有自定义类加载器</span></span><br><span class="line">                 scl = AccessController.doPrivileged(</span><br><span class="line">                     <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">             &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">       </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//设置sclSet为真</span></span><br><span class="line">         sclSet = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>initSystemClassLoader</code>主要就是初始化系统类加载器的，但是若用户自定义了类加载器，就会将<code>scl</code>初始化为用户自定义类加载器，这部分是通过<code>ClassLoader</code>的一个内部类来实现的。</p></blockquote><h4 id="SystemClassLoaderAction"><a href="#SystemClassLoaderAction" class="headerlink" title="SystemClassLoaderAction"></a>SystemClassLoaderAction</h4><p><code>SystemClassLoaderAction</code>是一个内部类，最后就是通过这个内部类来完成最后的类加载器初始化工作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">ClassLoader</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//从系统属性中获取key，即用户自定义类加载器的二进制名</span></span><br><span class="line">        String cls = System.getProperty(<span class="string">"java.system.class.loader"</span>);</span><br><span class="line">        <span class="comment">//若cls为空，则返回parent，即传入的系统类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过这个自定义类加载器的二进制名，使用系统类加载器去将其加载，并将其初始化</span></span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="keyword">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        <span class="comment">//通过反射创建这个自定义类加载器的实例</span></span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; parent &#125;);</span><br><span class="line">        <span class="comment">//将线程上下文类加载器设置为这个自定义类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        <span class="keyword">return</span> sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个内部类通过构造函数，传入通过<code>Launcher</code>创建的系统类加载器，然后再尝试去加载系统属性<code>java.system.class.loader</code>中保存的自定义类加载器的二进制类名。</p></blockquote><h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><p>刚刚在上文中说了<code>initSystemClassLoader</code>方法是通过创建一个<code>Launcher</code>类的实例，通过调用这个实例的<code>getClassLoader()</code>方法来获取到系统类加载器的。现在我们就来分析分析<code>Launcher</code>类，因为代码是由<code>IDEA</code>反编译出来的，所以参数名是由<code>IDEA</code>自己生成的。</p><p>首先，来看看<code>Launcher</code>类内部维护的重要的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"><span class="keyword">private</span> ClassLoader loader;</span><br></pre></td></tr></table></figure><blockquote><p>首先，第一个是启动类加载器所要加载的<code>jar</code>包的路径。</p><p>第二个是一个类加载器字段，上文<code>getClassLoader()</code>所获取的一个类加载器就是这个字段。</p></blockquote><p>再来来看看构造方法（没有安全管理部分的代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个扩展类加载器</span></span><br><span class="line">       Launcher.ExtClassLoader var1;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建一个扩展类加载器</span></span><br><span class="line">           var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//将内部维护的一个ClassLoader赋值为系统类加载器</span></span><br><span class="line">           <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//设置线程上下文类加载为系统类加载器</span></span><br><span class="line">       Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里在构造方法中声明扩展类加载器，而不将其设置为全局变量的原因是，可以直接通过系统类加载器的<code>getParent()</code>来获取扩展类加载器。</p></blockquote><h4 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h4><p>在<code>Launcher</code>的构造方法中，通过<code>AppClassLoader.getAppClassLoader</code>来获取系统类加载器，其实<code>AppClassloader</code>就是我们所说的系统类加载器，它是<code>Launcher</code>的一个内部类，它的最顶层父类也是<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取系统类加载器要加载的jar包路径以及当前Java程序classPath路径</span></span><br><span class="line">        <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="comment">//根据这些路径，创建一个文件数组</span></span><br><span class="line">        <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="comment">//访问控制操作和决策</span></span><br><span class="line">        <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//将文件数组转换成一个URL数组</span></span><br><span class="line">                URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                <span class="comment">//将当前的资源URL数组以及扩展类加载器传入这个内部类的构造方法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后通过<code>ClassLoader</code>的构造方法，创建出当前的这个类加载器，即系统类加载器，且扩展类加载器被设置为它的父类加载器。</p></blockquote><p>扩展类加载<code>ExtClassLoader</code>和系统类加载器是差不多的，也是<code>Launcher</code>类的一个内部类，它从系统属性<code>java.ext.dirs</code>中获取要加载的<code>jar</code>包的路径。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>前面分析了<code>Launcher</code>类，我们来看看它是由哪个类加载器加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest15</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">     System.getProperty(<span class="string">"java.system.class.loader"</span>);</span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\Program Files\Java\jdk\jre\lib\resources.jar;F:\Program Files\Java\jdk\jre\lib\rt.jar;F:\Program Files\Java\jdk\jre\lib\sunrsasign.jar;F:\Program Files\Java\jdk\jre\lib\jsse.jar;F:\Program Files\Java\jdk\jre\lib\jce.jar;F:\Program Files\Java\jdk\jre\lib\charsets.jar;F:\Program Files\Java\jdk\jre\lib\jfr.jar;F:\Program Files\Java\jdk\jre\classes</span><br><span class="line">-------------</span><br><span class="line">F:\Program Files\Java\jdk\jre\lib\ext;C:\windows\Sun\Java\lib\ext</span><br><span class="line">-------------</span><br><span class="line">F:\Program Files\Java\jdk\jre\lib\charsets.jar;F:\Program Files\Java\jdk\jre\lib\deploy.jar;F:\Program Files\Java\jdk\jre\lib\ext\access-bridge-<span class="number">64</span>.jar;F:\Program Files\Java\jdk\jre\lib\ext\cldrdata.jar;F:\Program Files\Java\jdk\jre\lib\ext\dnsns.jar;F:\Program Files\Java\jdk\jre\lib\ext\jaccess.jar;F:\Program Files\Java\jdk\jre\lib\ext\jfxrt.jar;F:\Program Files\Java\jdk\jre\lib\ext\localedata.jar;F:\Program Files\Java\jdk\jre\lib\ext\nashorn.jar;F:\Program Files\Java\jdk\jre\lib\ext\sunec.jar;F:\Program Files\Java\jdk\jre\lib\ext\sunjce_provider.jar;F:\Program Files\Java\jdk\jre\lib\ext\sunmscapi.jar;F:\Program Files\Java\jdk\jre\lib\ext\sunpkcs11.jar;F:\Program Files\Java\jdk\jre\lib\ext\zipfs.jar;F:\Program Files\Java\jdk\jre\lib\javaws.jar;F:\Program Files\Java\jdk\jre\lib\jce.jar;F:\Program Files\Java\jdk\jre\lib\jfr.jar;F:\Program Files\Java\jdk\jre\lib\jfxswt.jar;F:\Program Files\Java\jdk\jre\lib\jsse.jar;F:\Program Files\Java\jdk\jre\lib\management-agent.jar;F:\Program Files\Java\jdk\jre\lib\plugin.jar;F:\Program Files\Java\jdk\jre\lib\resources.jar;F:\Program Files\Java\jdk\jre\lib\rt.jar;D:\jvm\target\classes;C:\Users\Administrator\AppData\Local\JetBrains\Toolbox\apps\IDEA-U\ch-<span class="number">0</span>\<span class="number">183.5429</span>.30\lib\idea_rt.jar</span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示出了，这三个类加载器所要加载的一些<code>jar</code>包或者路径，因为我们没设置自定义类加载的加载路径，所以返回为空。<code>ClassLoader</code>和<code>Launcher</code>的类加载器，输出为<code>null</code>，其实并不是没有类加载器的意思，而是在<code>Java</code>虚拟机中，获取类加载器时，<code>null</code>就代表着启动类加载器，也就是说，<code>ClassLoader</code>和<code>Launcher</code>类都是由启动类加载器加载到内存中的。我们也可以验证一下，<code>Launcher</code>类属于<code>sun.misc</code>包，这个包属于<code>charsets.jar</code>包下，从上面的输出结果中，可以看到这个包是由启动类加载器加载的；而<code>ClassLoader</code>类是位于<code>java.lang</code>包下，位于<code>resources.jar</code>包下，同样也是由启动类加载器加载的。</p></blockquote><p>在前面的文章中，我们说过，当加载一个内部有引用其他类的类时，就会使用当前类的类加载器去尝试加载这些引用的类，我们也可以测试下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest0</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">        <span class="comment">//获得系统类加载</span></span><br><span class="line">        ClassLoader classLoader = launcher.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        System.out.println(classLoader.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">//获得扩展类加载器</span></span><br><span class="line">        System.out.println(classLoader.getParent());</span><br><span class="line">        System.out.println(classLoader.getParent().getClass().getClassLoader());</span><br><span class="line">        System.out.println(classLoader.getParent().getParent());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">74</span>a14482</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果验证了我们的说法，系统类加载器和扩展类加载器都是由启动类加载器加载的，当加载这两个加载器时，也就是对这两个类的主动使用，会首先加载它们的父类，也就导致了<code>ClassLoader</code>的加载。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;getSystemClassLoader&quot;&gt;&lt;a href=&quot;#getSystemClassLoader&quot; class=&quot;headerlink&quot; title=&quot;getSystemClassLoader&quot;&gt;&lt;/a&gt;getSystemClassLoader&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="Launcher类" scheme="http://wuyuzhao666.github.io/tags/Launcher%E7%B1%BB/"/>
    
      <category term="getSystemClassLoader" scheme="http://wuyuzhao666.github.io/tags/getSystemClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（五）：自定义类加载器与深入双亲委托机制</title>
    <link href="http://wuyuzhao666.github.io/2019/03/17/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E6%B7%B1%E5%85%A5%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E6%B7%B1%E5%85%A5%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://wuyuzhao666.github.io/2019/03/17/类加载机制（五）：自定义类加载器与深入双亲委托机制/类加载机制（五）：自定义类加载器与深入双亲委托机制/</id>
    <published>2019-03-17T00:24:05.000Z</published>
    <updated>2019-03-17T11:40:38.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们知道类加载器共分为两大类型，<code>Java</code>虚拟机自带的类加载器和自定义类加载器。<code>Java</code>虚拟机自带的类加载器分别加载了不同路径下的<code>class</code>文件，而有时我们需要加载一些特殊的<code>class</code>文件，如这个<code>class</code>文件是被加密的，我们就需要自己定义类加载器去解密加载它，又比如我们需要从网络或者直接从数据库中读取<code>class</code>文件，我们也需要自己定义类加载。</p><p>上文（<a href="/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/">类加载机制（四）：解析ClassLoader</a>）我们介绍分析了<code>ClassLoader</code>类，知道这个类是一个抽象类，除了<code>Java</code>虚拟机内建的启动类加载器以为，所有的类加载器都继承于它，并且要重载它的一个方法<code>findClass</code>去搜寻指定名字的<code>class</code>文件，并且如果在一个类中，又有其他类的引用，也是先通过调用类的类加载器先尝试去加载。在此篇文章，我们自定义一个类加载器去加载本地文件系统中的<code>class</code>文件来深入剖析双亲委托机制。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>首先来看看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"><span class="comment">//定义一个className，表示自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"><span class="comment">//定义一个path，表示class文件所在目录</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//同其父类ClassLoader一样，有两个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重载的findClass方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//测试自定义类加载器是否执行成功</span></span><br><span class="line">            System.out.println(<span class="string">"自定义class loader name: "</span> + <span class="keyword">this</span>.className);</span><br><span class="line">            <span class="comment">//调用MyLoadClass获取字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">this</span>.MyLoadClass(name);</span><br><span class="line">            <span class="comment">//调用</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(<span class="keyword">null</span>,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] MyLoadClass(String className) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将传入的类的二进制名转换为类的全限定名（包名+类名）</span></span><br><span class="line">        String replace = className.replace(<span class="string">"."</span>, File.separator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将这个class文件转换成字节数组</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.path + replace + <span class="string">".class"</span>);</span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read()))&#123;</span><br><span class="line">                bis.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = bis.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上代码所示，这个简易的自定义类加载器同样有两个构造方法，没有父类加载器传入的构造方法会调用<code>ClassLoader</code>的无参的构造方法，将系统类加载器设置为这个自定义类加载器的父类加载器；有父类类加载器传入的构造函数，也会调用<code>ClassLoader</code>的构造方法，只不过调用的是有参的构造方法，将传入的这个类加载器设置为这个自定义类加载器的父类加载器。</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>具体的实现，在注释中，就不过多阐述了。我们在<code>findClass</code>中写了句测试语句<code>System.out.println(&quot;自定义class loader name: &quot; + this.className);</code>,来测试自定义类加载器是否执行成功。到这我们就可以在启动类中进行测试了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeLoad</span><span class="params">(MyClassLoader loader,String className)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      loader.setPath(***********);</span><br><span class="line">      Class&lt;?&gt; loadClass = loader.loadClass(className);</span><br><span class="line">    <span class="comment">//打印出Class对象的hash码</span></span><br><span class="line">      System.out.println(className + <span class="string">"的class对象的hashCode:"</span> + loadClass.hashCode());</span><br><span class="line">    <span class="comment">//创建一个示例</span></span><br><span class="line">      Object o = loadClass.newInstance();</span><br><span class="line">      System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>写了一个执行方法，减少代码，并且在指定的<code>path</code>中放入<code>MyTest1</code>的<code>class</code>文件：</p><ul><li>传入自定义类加载器的实例与要加载的类的二进制名字。</li><li>在方法体里面指定好要加载的<code>class</code>文件目录。</li><li>调用父类的<code>loadClass</code>方法进行加载（<code>ClassLoader</code>具体怎么加载，见<a href="/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/">类加载机制（四）：解析ClassLoader</a>）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">    MyClassLoader.executeLoad(loader1,<span class="string">"classLoader.MyTest1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classLoader.MyTest1的class对象的hashCode:1163157884</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>竟然只输出了<code>MyTest1</code>的class对象的<code>hashCode</code>，意思是我们的自定义类加载未执行(<code>System.out.println(&quot;自定义class loader name: &quot; + this.className);</code>)</p><p>(⊙o⊙)，怎么回事？</p></blockquote><h5 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h5><p>我们知道关于类的加载也就是<code>class</code>文件的搜索与加载过程是由类加载器完成的，而类加载器又是遵循双亲委托机制的，关于这个机制就不多说了，见以前的文章。</p><p><a href="/2019/03/14/类加载机制（三）：类的加载与类加载器/类加载机制（三）：类的加载与类加载器/">类加载机制（三）：类的加载与类加载器</a></p><p><a href="/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/">类加载机制（四）：解析ClassLoader</a></p><p>在<code>MyClassLoader</code>中我们首先调用<code>ClassLoader</code>的<code>loadClass</code>方法，在<code>loadClass</code>中，最终会调用我们重载的这个<code>findClass</code>方法，但现在我们重载的<code>findClass</code>并没有被调用，说明有其他的<code>findClass</code>调用了。那我们在<code>executeLoad</code>中打印下加载的这个<code>class</code>对象的类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"我就是它加载的："</span> + loadClass.getClassLoader());</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我就是它加载的：sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">classLoader.MyTest1的class对象的hashCode:1163157884</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>结果显示<code>MyTest1</code>是由系统类加载器加载的。</p></blockquote><p>现在水落石出了，原来我们想要加载的<code>MyTest1</code>被系统类加载器给加载了，那为什么呢，其实联想下双亲委托机制就明白了。<code>MyClassLoader</code>收到要加载某个类的请求，就往其父类加载器（系统类加载器）传递，然后，一层层传递，导启动类加载器后，又往下传回来，传到系统类加载器后，系统类加载器发现自己能加载这个类，然后就截胡了，<code>MyTest1.class</code>就被系统类加载器加载到内存中去了。</p><hr><p>我们知道，系统类加载器是从<code>classPath</code>或者<code>java.class.path</code>系统属性中去加载<code>class</code>文件和<code>jar</code>包的，那我们把<code>classPath</code>中的<code>MyTest1.class</code>给删除掉，结果又会怎么样呢？</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自定义class loader name: loader1</span><br><span class="line">我就是它加载的：classLoader.MyClassLoader@<span class="number">4554617</span>c</span><br><span class="line">classLoader.MyTest1的class对象的hashCode:356573597</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示：我们的<code>MyClassLoader</code>起作用啦，注意这里<code>hashCode</code>不一样哦(⊙x⊙;)。</p></blockquote><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">       MyClassLoader.executeLoad(loader1,<span class="string">"classLoader.MyTest1"</span>);</span><br><span class="line">       MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">       MyClassLoader.executeLoad(loader2,<span class="string">"classLoader.MyTest1"</span>);</span><br><span class="line">    <span class="comment">//loader2是loader3的类加载器</span></span><br><span class="line">       MyClassLoader loader3 = <span class="keyword">new</span> MyClassLoader(loader2,<span class="string">"loader3"</span>);</span><br><span class="line">       MyClassLoader.executeLoad(loader3,<span class="string">"classLoader.MyTest1"</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>再创建两个<code>MyClassLoader</code>的实例。loader2–&gt;loader3</p></blockquote><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自定义class loader name: loader1</span><br><span class="line">我就是它加载的：classLoader.MyClassLoader@<span class="number">4554617</span>c</span><br><span class="line">classLoader.MyTest1的class对象的hashCode:356573597</span><br><span class="line">--------------</span><br><span class="line">自定义class loader name: loader2</span><br><span class="line">我就是它加载的：classLoader.MyClassLoader@<span class="number">677327</span>b6</span><br><span class="line">classLoader.MyTest1的class对象的hashCode:2133927002</span><br><span class="line">--------------</span><br><span class="line">我就是它加载的：classLoader.MyClassLoader@<span class="number">677327</span>b6</span><br><span class="line">classLoader.MyTest1的class对象的hashCode:2133927002</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示：<code>loader2</code>加载获得的<code>class</code>对象和<code>loader3</code>加载获得的<code>class</code>是一样的。</p></blockquote><p>这个结果其实<code>ClassLoader</code>类中的<code>loadClass</code>很清楚：</p><ul><li>类只会被加载一次（<code>findLoadedClass(String)</code>），返回的<code>class</code>对象都一样。若没有<code>class</code>文件，则会调用当前加载器的<code>findClass</code>方法去查找<code>class</code>文件。</li><li>双亲委托机制是包含关系，实例化<code>loader3</code>时可以让<code>loader2</code>作为自己的父加载器，创建<code>loader3</code>去加载<code>MyTest1</code>时，因为<code>loader2</code>已经加载过了（<code>findLoadedClass(String)</code>），所以使用<code>loader3</code>加载时，<code>loader3</code>直接返回了已经加载过的<code>MyTest1</code>的<code>class</code>对象。</li></ul><h2 id="深入双亲委托机制"><a href="#深入双亲委托机制" class="headerlink" title="深入双亲委托机制"></a>深入双亲委托机制</h2><p>我们通过一些示例代码来进行分析。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印出MyCat的类加载器器</span></span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印出MySample的类加载器器</span></span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="comment">//在MySample的构造方法中创建一个MyCat的实例</span></span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载MySample类</span></span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        MyClassLoader.executeLoad(loader1,<span class="string">"refenLoad.MySample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">refenLoad.MySample的class对象的hashCode:1956725890</span><br><span class="line">MySample is loaded by:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">--------------</span><br><span class="line">MyCat is loaded by:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p>具体过程如下：</p><blockquote><ul><li>调用<code>MyClassLoader</code>加载<code>MySample</code>类。</li><li><code>classPath</code>中有<code>MySample</code>类的<code>class</code>文件，系统类加载器将其加载到内存中。</li><li>然后因为在<code>executeLoad</code>方法中创建了对象实例，<code>MySample</code>被首次主动使用，即进行初始化，调用构造函数完成初始化。</li><li>在<code>MySample</code>的构造函数中<code>new MyCat()</code>，即对<code>MyCat</code>的首次主动使用，经历加载连接初始化。</li></ul></blockquote><hr><p>接着，复制一份<code>MySample</code>的<code>class</code>文件到我们设定的<code>path</code>中，删除到<code>classPath</code>中的那份，结果怎么样呢。</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">自定义class loader name: loader1</span><br><span class="line">refenLoad.MySample的class对象的hashCode:1735600054</span><br><span class="line">MySample is loaded by:classLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">--------------</span><br><span class="line">MyCat is loaded by:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>为什么，两个类的类加载器又不一样呢？</p></blockquote><ul><li>因为<code>classPath</code>中没有<code>MySample</code>的<code>class</code>文件，所以经过双亲委托机制，最终是通过<code>MyClassLoader</code>来加载我们自己的<code>MySample</code>文件。</li><li>创建<code>MySample</code>实例时，进行<code>MySample</code>的初始化，执行<code>MySample</code>的构造方法。</li><li><code>MySample</code>的构造方法里创建<code>MyCat</code>实例，<em>使用加载<code>MySample</code>的类加载器</em>来加载<code>MyCat</code>。</li><li><code>MyClassLoader</code>加载器委托系统加载器来加载<code>MyCat.class</code>，加载完成。</li></ul><hr><p>再接着，复制一份<code>MyCat</code>的<code>class</code>文件到我们设定的<code>path</code>中，删除到<code>classPath</code>中的那份，结果又怎么样呢。</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自定义class loader name: loader1</span><br><span class="line">refenLoad.MySample的class对象的hashCode:1735600054</span><br><span class="line">MySample is loaded by:classLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">--------------</span><br><span class="line">自定义class loader name: loader1</span><br><span class="line">MyCat is loaded by:classLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>它们的类加载器又都是<code>MyClassLoader</code>了。</p></blockquote><ul><li>因为<code>classPath</code>中没有<code>MySample</code>的<code>class</code>文件，所以经过双亲委托机制，最终是通过<code>MyClassLoader</code>来加载我们自己的<code>MySample</code>文件。</li><li>创建<code>MySample</code>实例时，进行<code>MySample</code>的初始化，执行<code>MySample</code>的构造方法。</li><li><code>MySample</code>的构造方法里创建<code>MyCat</code>实例，<em>使用加载<code>MySample</code>的类加载器</em><code>MyClassLoader</code>来加载<code>MyCat</code>，加载成功。</li></ul><p>如果只删除<code>MyCat.class</code>又会怎么样呢？</p><p>系统加载器加载<code>MySmple.class</code>，加载<code>MyCat</code>时，同样使用系统加载器来加载<code>MyCat</code>，但<code>classPath</code>中没有<code>MyCat.class</code>文件，最后就会抛出<code>java.lang.NoClassDefFoundError</code>异常。</p><hr><p>再再接着，<code>reBuild</code>项目，删除掉<code>MySample</code>的<code>class</code>文件，在<code>MyCat</code>的构造方法里打印<code>MySample</code>的class`。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"from MyCat:"</span> + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自定义class loader name: loader1</span><br><span class="line">refenLoad.MySample的class对象的hashCode:1735600054</span><br><span class="line">MySample is loaded by:classLoader.MyClassLoader@<span class="number">74</span>a14482</span><br><span class="line">--------------</span><br><span class="line">MyCat is loaded by:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p><img src="http://res.cloudinary.com/cafebabe/8WB0J_LXX_22D_E_3U_G_E.png"></p><blockquote><p>我们想在<code>MyCat</code>中调用<code>MySample</code>，竟然报错了，找不到<code>MySample</code>类，这里涉及到类的命名空间问题。</p></blockquote><p>最后，只删除<code>classPath</code>中的<code>MySample</code>的<code>class</code>文件，在<code>MySample</code>的构造方法中打印<code>MyCat</code>的<code>class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by:"</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"from MyCat:"</span> + MyCat.class);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refenLoad.MySample的class对象的hashCode:1956725890</span><br><span class="line">MySample is loaded by:sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">from MyCat:<span class="class"><span class="keyword">class</span> <span class="title">refenLoad</span>.<span class="title">MyCat</span></span></span><br><span class="line"><span class="class">--------------</span></span><br><span class="line">MyCat is loaded by:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，这里就打印成功，也就是说，在<code>MySample</code>中调用<code>MyCat</code>成功，这里同样也是命名空间的问题。</p></blockquote><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>每个类加载器都有自己的命名空间，<em>命名空间由该加载器及所有父加载器所加载的类组成</em>。</p><ul><li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><h6 id="命名空间之间的关系"><a href="#命名空间之间的关系" class="headerlink" title="命名空间之间的关系"></a>命名空间之间的关系</h6><p>同一个命名空间内的类是相互可见的。</p><p>子加载器的命名空间包含所有父加载器的命名空间。因此由只加载器加载的类能看见父加载器加载的类。例如系统类加载器可以看见根类加载器加载的类。</p><p>由父加载器加载的类不能看见子加载器加载的类。</p><p>如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类互不可见。</p><hr><p>了解了命名空间后，就明白前面代码的输出结果了。</p><p>（1）删除掉<code>MySample</code>的<code>class</code>文件，在<code>MyCat</code>的构造方法里打印<code>MySample</code>的<code>class</code>。<code>MySample</code>由<code>MyClassLoader</code>加载，<code>MyCat</code>由<code>AppClassLoader</code>加载，父加载器加载的类是看不到子加载器加载的类，则在<code>MyCat</code>中看不到<code>MySample</code>。 </p><p>（2）删除掉<code>MySample</code>的<code>class</code>文件，在<code>MySample</code>的构造方法中打印<code>MyCat</code>的<code>class</code>，<code>MySample</code>由<code>MycalssLoader</code>加载，<code>MyCat</code>由<code>AppClassLoader</code>加载，子加载器能够看见父加载器加载的类，则<code>MySample</code>可以看到<code>MyCat</code>的<code>class</code>。 </p><h5 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h5><p>复制一份<code>MyPerson.class</code>到指定的路径下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内部维护一个MyPerson的类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> MyPerson person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//传进来一个对象，强制转换为MyPerson</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (MyPerson)o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建两个MyClassLoader的实例，都去加载位于path路径下的MyPerson.class文件</span></span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\Administrator\\Desktop\\jvmTest\\"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\Administrator\\Desktop\\jvmTest\\"</span>);</span><br><span class="line">        <span class="comment">//分别去加载MyPerson.class,得到其class对象</span></span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"classLoader.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"classLoader.MyPerson"</span>);</span><br><span class="line">        <span class="comment">//比较两个class对象是否相等</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        <span class="comment">//通过class对象，创建实例</span></span><br><span class="line">        Object o1 = clazz1.newInstance();</span><br><span class="line">        Object o2 = clazz2.newInstance();</span><br><span class="line">        <span class="comment">//使用反射的方式去调用MyPerson的setPerson方法</span></span><br><span class="line">        Method setPerson = clazz1.getMethod(<span class="string">"setPerson"</span>, Object.class);</span><br><span class="line">        <span class="comment">//调用o1的setPerson方法，将o2传进去。</span></span><br><span class="line">        setPerson.invoke(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><blockquote><p>通过系统类加载器加载，没什么问题。</p></blockquote><p>从<code>classPath</code>中删除掉<code>MyPerson.class</code>文件，再运行程序。</p><p><img src="http://res.cloudinary.com/cafebabe/58Q_M_T0_WN_1XGCZ_4V6.png"></p><blockquote><p>从结果可以看出，两个<code>class</code>对象最终都是由<code>MyClassLoader</code>来加载得到的，但是得到的<code>class</code>并不是同一个，并且在执行<code>o1</code>的<code>setPath</code>方法时还报错，说无法将<code>MyPerson</code>转换为<code>MyPerson</code>，这就很奇怪了？</p></blockquote><p>其实，想想类加载器的命名空间，还是挺简单的。</p><p>一个类在<code>Java</code>虚拟机中的唯一性，是由类与类加载器一起共同决定的，每一个类加载，都有自己独立的命名空间。在此处，<code>loader1</code>与<code>loader2</code>虽然都是<code>MyClassLoader</code>的实例，但是它们之间并不存在双亲委托的关系，即是两个不同的类加载器，即存在两个不同的命名空间，<code>clazz1</code>和<code>clazz2</code>属于不同的命名空间。使用反射去调用<code>MyPerson</code>的<code>serPerson</code>方法，想把<code>o2</code>赋值给<code>o1</code>中的<code>Person</code>属性，但因为<code>clazz1</code>和<code>clazz2</code>是属于不同的命名空间，推广开，<code>o1</code>和<code>o2</code>也属于不同的命名空间，两者之间是不可见的，所以不能将<code>o2</code>赋值给<code>o1</code>的<code>Person</code>属性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个自定义类加载器，我们深入剖析了类加载器的双亲委托机制，这里再放一遍关于类加载器的双亲委托模型的好处：</p><ul><li>可以确保<code>Java</code>核心类库的类型安全：所有的Java应用都至少会引用<code>java.lang.Object</code>类，也就是说在运行期，<code>java.lang.Object</code>这个类会被加载到Java虚拟机中；如果这个加载过程是由各自的类加载器去加载的话，那系统中会产生多个版本的<code>Object</code>类，这些类位于不同的命名空间中，相互之间不兼容，不可见，应用程序将会变得混乱。而通过双亲委托机制，<code>Java</code>核心类库中的类都由启动加载器来完成加载，从而保证了<code>Java</code>应用使用的都是同一个<code>Java</code>核心类库，它们之间是相互兼容的。</li><li>可以确保Java核心类库所提供的类不会被自定义的类所替代。</li><li>不同的类加载器可以加载相同名称的类，这些相同名称的类可以并存在<code>Java</code>虚拟机中。不同类加载器所加载的类是不兼容的，这就相当于在<code>Java</code>虚拟机中创建了一个又一个的相互隔离的<code>Java</code>类空间。</li></ul><p>最后，提一句，内建于<code>JVM</code>的启动类加载器会加载<code>java.lang.ClassLoader</code>以及其他的<code>Java</code>平台类，当<code>JVM</code>启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器（<code>Bootstap</code>）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们知道类加载器共分为两大类型，&lt;code&gt;Java&lt;/code&gt;虚拟机自带的类加载器和自定义类加载器。&lt;code&gt;Java&lt;/code&gt;虚
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="自定义类加载器" scheme="http://wuyuzhao666.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（四）：解析ClassLoader</title>
    <link href="http://wuyuzhao666.github.io/2019/03/15/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%A7%A3%E6%9E%90ClassLoader/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%A7%A3%E6%9E%90ClassLoader/"/>
    <id>http://wuyuzhao666.github.io/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/</id>
    <published>2019-03-15T12:28:24.000Z</published>
    <updated>2019-03-20T00:19:20.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><h4 id="ClassLoader介绍"><a href="#ClassLoader介绍" class="headerlink" title="ClassLoader介绍"></a>ClassLoader介绍</h4><p><code>ClassLoader</code>顾名思义就是类加载器，它是一个直接继承<code>Object</code>的抽象类，除了启动类加载器以外，所有的类加载器都继承<code>ClassLocader</code>类，应用程序可以去实现这个抽象类，来扩展<code>Java</code>虚拟机加载类的方式。一个类加载器的作用就是加载类，通过一个类的二进制名，一个类加载器就可以通过这个类的二进制名去尝试定位或者生成（在动态加载中，类加载器可以去生成字节码数据）这个二进制名所定义的字节码数据。它的一般策略就是先将这个二进制名转换成这个类的<code>Class</code>文件名，然后从文件系统中读取这个文件。</p><blockquote><p>二进制名(binary name)：<code>Java</code>虚拟机规范规定类加载器加载的类名必须是一个规范的字符串。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    （<span class="number">1</span>）<span class="string">"java.lang.String"</span></span><br><span class="line">&gt;      （<span class="number">2</span>）<span class="string">"javax.swing.JSpinner$DefaultEditor"</span></span><br><span class="line">&gt;      （<span class="number">3</span>）<span class="string">"java.security.KeyStore$Builder$FileBuilder$1"</span></span><br><span class="line">&gt;      （<span class="number">4</span>）<span class="string">"java.net.URLClassLoader$3$1"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）表示<code>javax.swing.JSpinner</code>的内部类<code>DefaultEditor</code>。</p><p>（3）表示<code>java.security.KeyStore</code>的内部类<code>Builder</code>的内部类<code>FileBuilder</code>中的第一个内部类。</p><p>/(ㄒoㄒ)/~~</p></blockquote><p>每一个类的<code>Class</code>对象都包含着对其类加载器的引用，意思是可以直接通过类的<code>Class</code>对象获取其类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader();</span><br></pre></td></tr></table></figure><p>对于数组来说，它的<code>Class</code>对象不是由类加载来加载创建的，而是在运行期自动创建的。但是对于元素为引用类型的数组来说，是可以通过<code>clazz.getClassLoader()</code>返回类加载器的，只不过返回的是它的<code>component</code>的类加载器。对于元素类型是基本类型的数组来说，是没有类加载器的。</p><h4 id="ClassLoader源码解析"><a href="#ClassLoader源码解析" class="headerlink" title="ClassLoader源码解析"></a>ClassLoader源码解析</h4><h5 id="ClassLoader的机制"><a href="#ClassLoader的机制" class="headerlink" title="ClassLoader的机制"></a>ClassLoader的机制</h5><p>这个<code>ClassLoader</code>类是通过双亲委托模型来寻找类和资源的（<a href="/2019/03/14/类加载机制（三）：类的加载与类加载器/类加载机制（三）：类的加载与类加载器/">见前文：类加载机制（三）：类的加载与类加载器</a>）：每一个类加载器都有一个父加载器，当收到加载一个类的请求时，类加载器就会去委托它的父加载器去尝试加载类，虚拟机内建的类加载，即启动类加载器是没有父加载器，它是作为类加载器实例的父加载器的。</p><hr><h6 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></table></figure><blockquote><p><code>ClassLoader</code>类内部维护了一个<code>ClassLoader</code>,代表着当前类加载器的父加载器。</p></blockquote><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>有参的构造函数，chuan’jian通过传入一个类加载器作为当前类加载器的父加载器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>无参的构造函数，使用<code>getSystemClassLoader()</code>获取到系统类加载器作为当前类加载器的父加载器（这个方法也会在后面进行分析）。</p></blockquote><h6 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>loadClass(String name)</code>方法是<code>ClassLoader</code>类中默认的加载类的方法，它可以加载具有指定的二进制名的类。调用这个方法等价于调用<code>loadClass(name, false)</code>。</p></blockquote><p>再来看看<code>loadClass(name, false)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查这个类是否已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//若父类加载器不为空，使用父类加载器去加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若父类加载器为空，使用虚拟机内置的启动类加载器进行加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//若仍没加载到，就调用findClass(name)来找到这个类，调用的是</span></span><br><span class="line">                    <span class="comment">//当前类加载器的 findClass(String)方法</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若resolve参数为真，就调用resolveClass将这个class对象完成连接</span></span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>loadClass</code>的作用就是根据特定的二进制名加载类。在<code>ClassLoader</code>抽象类中，它搜寻<code>class</code>文件的默认实现是按如下步骤进行的：</p><ul><li><p>执行<code>findLoadedClass(String)</code>查看类是否已经加载加载器不能加载的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">&gt;           <span class="comment">//检查这个二进制名是否合法</span></span><br><span class="line">&gt;           <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">&gt;               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;           <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;   </span><br><span class="line">&gt;       <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><blockquote><p>如果<code>Java</code>虚拟机已经将这个类加载器记录为这个二进制名代表的类的类加载器后，就直接返回这个二进制名代表的类的<code>class</code>对象，否则，就返回<code>null</code>。而这一</p></blockquote><ul><li><p>执行当前类的父类加载器的<code>loadClass</code>。若<code>parent</code>为空，则使用<code>Java</code>虚拟机的内置根加载器来进行加载。</p></li><li><p>执行<code>findClass(String)</code>来找到这个类，调用的是当前类加载器的 <code>findClass(String)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">&gt;           <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><blockquote><p><code>findClass(String)</code>的作用是根据二进制名找到<code>class</code>文件，将<code>class</code>文件转换为字节数组，如上代码所示，这个类是没有执行语句的，所以这个类是需要继承了<code>ClassLoader</code>的类加载器来重载来完成上述功能的，且这个类加载器的实现是遵循双亲委托机制的，这个方法是由<code>loadClass</code>方法调用的。</p></blockquote><ul><li><p>最后，就可以执行<code>defineClass</code>方法了，将<code>Class</code>文件的字节数组转换成<code>Class</code>对象的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">&gt;           <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&gt;       &#123;</span><br><span class="line">&gt;           <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><blockquote><p>当传入类的二进制名（可以为空），字节数组，偏移量，数组长度，就由<code>Java</code>虚拟机来完成最后的加载工作。</p></blockquote></blockquote><p>从上文所诉的过程，可以看出加载类的过程其实很简单，当时也体现出了双亲委托机制的思想，从当前类开始，不断的调用其父类加载器，直到启动类加载器为止。</p><p>下篇博客，我会用一个自定义类加载器来深入剖析双亲委托机制。<a href="/2019/03/16/类加载机制（三）：类的加载与类加载器/类加载机制（三）：类的加载与类加载器/">类加载机制（五）：自定义类加载器与深入双亲委托机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ClassLoader类&quot;&gt;&lt;a href=&quot;#ClassLoader类&quot; class=&quot;headerlink&quot; title=&quot;ClassLoader类&quot;&gt;&lt;/a&gt;ClassLoader类&lt;/h2&gt;&lt;h4 id=&quot;ClassLoader介绍&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="ClassLoader" scheme="http://wuyuzhao666.github.io/tags/ClassLoader/"/>
    
      <category term="源码解析" scheme="http://wuyuzhao666.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（三）：类的加载与类加载器</title>
    <link href="http://wuyuzhao666.github.io/2019/03/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://wuyuzhao666.github.io/2019/03/14/类加载机制（三）：类的加载与类加载器/类加载机制（三）：类的加载与类加载器/</id>
    <published>2019-03-14T07:40:14.000Z</published>
    <updated>2019-03-21T09:32:22.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>类的加载属于<code>Java</code>虚拟机类加载机制的第一个阶段，它的作用就是将二进制形式的<code>Java</code>类型加载到内存中去，最终形成的就是内存中的<code>Class</code>对象，这个对象封装了类的数据结构。而这个加载过程，就是由一个叫类加载器的程序所完成的，也就是说，一个<code>Java</code>类是由类加载器所加载到内存中的。</p><h4 id="类的预先加载"><a href="#类的预先加载" class="headerlink" title="类的预先加载"></a>类的预先加载</h4><p>在类的加载中，类加载器并不需要等到某个类被<em>首次主动使用</em>时再加载它。<code>JVM</code>规范允许类加载器在预料到某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在<em>程序首次主动使用</em>该类时才报告错误（<code>LinkageError</code>）错误。</p><p>如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h2 id="类加载器与双亲委托机制"><a href="#类加载器与双亲委托机制" class="headerlink" title="类加载器与双亲委托机制"></a>类加载器与双亲委托机制</h2><p>顾名思义，类加载器就是用来把类加载到<code>Java</code>虚拟机中的。而从<code>JDK1.2</code>开始，类的加载就是遵循双亲委托机制来进行加载的，这种机制很好的保证了<code>Java</code>平台的安全与程序的有序。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载器一共有两种类型：</p><p><code>Java</code>虚拟机自带的加载器</p><blockquote><p>—-根类加载器（<code>Bootstrap</code>）</p><p>—-扩展类加载器（<code>Extension</code>）</p><p>—-系统（应用）加载器（<code>System</code>）</p></blockquote><p>用户自定义的类加载器</p><blockquote><p>—-<code>java.lang.classLoader</code>的子类</p><p>—-用户可以定制类的加载方式</p></blockquote><h5 id="虚拟机自带加载器"><a href="#虚拟机自带加载器" class="headerlink" title="虚拟机自带加载器"></a>虚拟机自带加载器</h5><ul><li><p>根（Bootstrp）类加载器（启动类加载器）：负责加载的虚拟机的核心类库，比如 <code>java.lang.*</code>等。根类加载器是从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。根类加载器本身的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并没有实现<code>java.lang.classLoader</code>类。</p></li><li><p>扩展类加载器（Extension）：负责加载JDK的安装目录的<code>jre\lib\ext</code>子目录下的类库，从系统属性<code>java.ext.dirs</code>所指定的目录中加载类库。扩展类加载器是纯<code>Java</code>类，它继承于<code>java.lang.classLoader</code>类。</p></li><li><p>系统（System）类加载器（应用类加载器）：从环境变量<code>classPath</code>或者从系统属性<code>java.class.path</code>所指定的目录下加载类，它是用户自定义类加载器的默认父加载器。系统类加载器是纯<code>Java</code>类，它继承于<code>java.lang.classLoader</code>类。</p></li></ul><h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><p>有时想对字节码文件进行加密处理，使用<code>Java</code>虚拟机自带的加载器就无法加载已经加了密的字节码文件，这时就可以使用自定义加载器对加密的字节码文件进行解密，就可以将其还原为正确的字节码文件 。</p><h4 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h4><p>在<code>Java</code>虚拟机的类加载阶段，<code>Java</code>程序一般是由上述的类加载器一起配合着加载的。而这些类加载器它们之间配合着加载类采用的是一种叫<em>双亲委托机制</em>的加载机制。除了根类加载器以外，每一个类加载器都有一个父类加载器。</p><p>双亲委托机制的基本流程是这样：当一个类接收到类的加载请求时，它首先不会对其进行加载，而是交给它的父加载器<code>Parent</code>来进行尝试加载，如果这个父加载器不能对这个类进行加载，就继续往上传递，一直到根类加载器为止，如果最后根类加载器也无法加载，又会一级级的传递下来，让适合的类加载器来进行加载。</p><center><img src="https://res.cloudinary.com/cafebabe/image/upload/v1552565156/sqwt-1.png"></center><blockquote><p>如上图所示，自定义类加载器<code>Loader1</code>想要加载<code>Test</code>类，它不会先去加载这个类，而是一级级的往上传递，到达根类加载器后，若根类记载器无法加载，再一级级的传递下来，最后才<code>Loader1</code>来完成加载。</p></blockquote><center><img src="https://res.cloudinary.com/cafebabe/image/upload/v1552568214/swqt-2.png"></center><p>需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包装关系，而不是类之间的继承关系。一对父子加载器可能是同一个类加载器类的两个不同实例，也可能不是。在子加载器对象中还包装了一个父加载器对象（<a href="/2019/03/15/类加载机制（四）：解析ClassLoader/类加载机制（四）：解析ClassLoader/">请看后续博客:类加载机制（四）：解析ClassLoader</a>）。</p><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><h5 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到系统类加载</span></span><br><span class="line">     ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    <span class="comment">//打印出各类加载器</span></span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">null</span> != classLoader)&#123;</span><br><span class="line">         <span class="comment">//获取此类加载器的父加载器</span></span><br><span class="line">         classLoader = classLoader.getParent();</span><br><span class="line">         System.out.println(classLoader);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>启动类加载器，即根类加载器为<code>null</code>。</p></blockquote><h5 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">        MyTest12[] myTest12s = <span class="keyword">new</span> MyTest12[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(strings.getClass());</span><br><span class="line">        System.out.println(strings.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        System.out.println(myTest12s.getClass());</span><br><span class="line">        System.out.println(myTest12s.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class [Ljava.lang.String;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">----------</span><br><span class="line">class [LclassLoader.MyTest12;</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">----------</span><br><span class="line">class [I</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><blockquote><p>前文已说过，基本数组类的<code>class</code>类型直接继承于<code>java.lang.Object</code>,从上可以看出，<code>component</code>类型为基本数据类型的数组是由启动类加载器所加载的，而引用类型的数组则是由系统类加载器加载的。</p></blockquote><h4 id="双亲委托机制的好处"><a href="#双亲委托机制的好处" class="headerlink" title="双亲委托机制的好处"></a>双亲委托机制的好处</h4><blockquote><p>考虑到章节的完整性，先<code>po</code>出双亲委托机制的好处，关于命名空间导致类不相同的问题，<a href>请看后续博客：类加载机制（五）：自定义类加载器与深入双亲委托机制</a>。</p></blockquote><ul><li><p>可以确保<code>Java</code>核心类库的类型安全，让<code>Java</code>类随着它的类加载器一起具备了一种带有优先级的层次关系：比如，所有的<code>Java</code>应用都至少会引用<code>java.lang.Object</code>类，也就是说在运行期，<code>java.lang.Object</code>这个类会被加载到<code>Java</code>虚拟机中；如果这个加载过程是由各自的类加载器去加载的话，那系统中会产生多个版本的<code>Object</code>类，这些类位于不同的命名空间中，相互之间不兼容，不可见，应用程序将会变得混乱。而通过双亲委托机制，<code>Java</code>核心类库中的类都由启动加载器来完成加载，从而保证了<code>Java</code>应用使用的都是同一个<code>Java</code>核心类库，它们之间是相互兼容的。</p></li><li><p>可以确保Java核心类库所提供的类不会被自定义的类所替代。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类的加载&quot;&gt;&lt;a href=&quot;#类的加载&quot; class=&quot;headerlink&quot; title=&quot;类的加载&quot;&gt;&lt;/a&gt;类的加载&lt;/h2&gt;&lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="类加载器" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制（二）：类的初始化</title>
    <link href="http://wuyuzhao666.github.io/2019/03/13/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://wuyuzhao666.github.io/2019/03/13/类加载机制（二）：类的初始化/类加载机制（二）：类的初始化/</id>
    <published>2019-03-13T10:49:55.000Z</published>
    <updated>2019-03-26T12:02:09.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>一般<code>Java</code>程序的<code>class</code>文件经过加载、连接后，就进入初始化阶段，顺序执行<code>static</code>语句，为静态变量赋予正确的值，执行<code>static</code>代码块，初始化类。</p><h4 id="类的使用方式"><a href="#类的使用方式" class="headerlink" title="类的使用方式"></a>类的使用方式</h4><p><code>Java</code>程序对类的使用分为两种：</p><p>—-主动使用</p><p>—-被动使用</p><p>所有的<code>Java</code>虚拟机实现必须在每个类或接口被<code>Java</code>程序<em>首次主动使用</em>时才会初始化它们。</p><h5 id="主动使用方式"><a href="#主动使用方式" class="headerlink" title="主动使用方式"></a>主动使用方式</h5><p>主动使用分为七种：</p><p>—-创建类的实例</p><p>—-访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>—-调用类的静态方法</p><p>—-反射（如<code>Class.forName(com.test.Test)</code>）</p><p>—-初始化一个子类</p><p>—-<code>Java</code>虚拟机启动时被标明为启动类的类</p><p>—-<code>JDK1.7</code>开始提供的动态语言支持：<code>java.lang.invoke.MethodHandle</code>实例的解析结果<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>句柄对应的类没有初始化，则初始化。</p><p>除了以上七种情况，其他使用<code>Java</code>类的方法都被看作是对类的被动使用，都不会导致类的初始化。</p><h5 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h5><p>对于类来说：</p><blockquote><p>假如这个类还没有被加载和连接，那就先进行加载和连接</p></blockquote><blockquote><p>假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化父类</p></blockquote><blockquote><p>假如类中存在初始化语句，那就一次执行这些初始化语句</p></blockquote><p>对于接口来说：</p><p>当<code>Java</code>虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><blockquote><p>在初始化一个类时，并不会先初始化它所实现的接口</p><p>在初始化一个接口时，并不会先初始化它的父接口</p></blockquote><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="NO-1"><a href="#NO-1" class="headerlink" title="NO.1"></a>NO.1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"parent str"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"parent static启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"son static启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><center><img src="http://res.cloudinary.com/cafebabe/mytest1.png"></center><blockquote><p>输出结果显示只有<code>Parent</code>类被加载了。对于静态字段来说，只有直接定义了该字段的类才会被初始化。虽然<code>Son</code>没有被主动使用，但它已经被加载了。类加载器并不需要等到某个类被<em>首次主动使用</em>时再加载它。</p></blockquote><p>将<code>Parent</code>类中的<code>str</code>变量注释掉，添加到<code>Son</code>类中</p><p>输出结果：</p><center><img src="http://res.cloudinary.com/cafebabe/mytest1-2.png"></center><blockquote><p>输出结果显示<code>Parent</code>类与<code>Son</code>类都被初始化了。通过使用<code>Son</code>的静态变量，导致<code>Son</code>的初始化，而当一个类在初始化时，首先要求其父类全部都已经初始化，即导致<code>Parent</code>初始化。</p></blockquote><p>我们还可以从第一段打印类加载信息（通过添加虚拟机参数<code>-XX:+TraceClassLoading</code>）看出，虽然<code>Son</code>没有被主动使用，但它已经被加载了。类加载器并不需要等到某个类被“首次主动使用”时再加载它。</p><h5 id="NO-2"><a href="#NO-2" class="headerlink" title="NO.2"></a>NO.2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent2.str);</span><br><span class="line">        System.out.println(Parent2.bi);</span><br><span class="line">        System.out.println(Parent2.si);</span><br><span class="line">        System.out.println(Parent2.icons_1);</span><br><span class="line">        System.out.println(Parent2.iconst_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"Hello Jvm"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> bi = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> si = <span class="number">32767</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> icons_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> iconst_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent2 init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello Jvm</span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">32767</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>将<code>Parent</code>的<code>class</code>文件从<code>classPath</code>中删除掉，再运行程序，程序没报错，输出结果一样。</p><blockquote><p>常量的本质含义：常量在编译阶段会存入调用这个常量的常量池中。本质上，调用这个常量并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。如：<code>Paren2</code>中定义的常量被存入到了<code>MyTest2</code>中，之后两个类就没有任何关系了。甚至将<code>Paren2</code>的<code>.class</code>文件删除也没关系。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Paren3 init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Paren3 init</span><br><span class="line"><span class="number">2</span>b00eb3dbd934bf7ab610407058d276f</span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示<code>Parent3</code>被成功初始化了。而且，删除掉<code>Parent3</code>的<code>class</code>文件，也会报<code>java.lang.NoClassDefFoundError</code>的错误。</p></blockquote><p>在编译期间，对于并不能确定的常量来说，不会被存入到调用类的常量池中。而是在运行期间，主动使用常量的所属类，完成所属类的初始化。</p><h5 id="NO-3"><a href="#NO-3" class="headerlink" title="NO.3"></a>NO.3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Parent4 parent4 = new Parent4();</span></span><br><span class="line">        Parent4[] parent4s = <span class="keyword">new</span> Parent4[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(parent4s.getClass());</span><br><span class="line">        System.out.println(parent4s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"=============="</span>);</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent4</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Paren4 init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class [LclassLoader.Parent4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"></span>==============</span><br><span class="line">class [I</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示并没有触发<code>Parent</code>的初始化过程，但是却触发了<code>class [LclassLoader.Parent4;</code>的初始化阶段，打印出的这个名称，它直接继承<code>class java.lang.Object</code>，代表了数组的<code>component</code>，即数组的组成元素。</p></blockquote><p>将<code>class</code>文件反编译后，可以看出它的创建动作由助记符<code>newarray</code>触发。</p><center><img src="http://res.cloudinary.com/cafebabe/mytest4.png"></center><p><code>anewarray</code>：表示创建一个引用类型的数组（类、接口、数组），并将其引用值压入栈顶。<br><code>newarray</code>：表示创建一个基本类型的数组（int、char），并将其引用值压入栈顶。</p><h5 id="NO-4"><a href="#NO-4" class="headerlink" title="NO.4"></a>NO.4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Single instance = Single.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"count1:"</span> + Single.count1);</span><br><span class="line">        System.out.println(<span class="string">"count2:"</span> + Single.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(<span class="string">"构造方法count1:"</span> + count1);</span><br><span class="line">        System.out.println(<span class="string">"构造方法count2:"</span> + count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法count1:<span class="number">1</span></span><br><span class="line">构造方法count2:<span class="number">1</span></span><br><span class="line">count1:<span class="number">1</span></span><br><span class="line">count2:<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>MyTest6</code>中调用<code>Single</code>的静态方法，触发<code>Single</code>的初始化阶段。</p><p>—-连接阶段，将静态变量全置为默认值：</p><p><code>count1 = 0</code></p><p><code>count2 = 0</code></p><p><code>single = null</code></p><p>—-初始化阶段，顺序执行静态语句：</p><p>执行到此句时 <code>private static Single single = new Single();</code>,执行<code>Single</code>的构造方法。</p><p><code>count1 = 1</code></p><p><code>count2 = 1</code></p><p>并将其打印，最后再在<code>MyTest6</code>的<code>main</code>方法中调用时，直接从<code>Single</code>的常量池中取出。</p></blockquote><p>修改下<code>Single</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(<span class="string">"构造方法count1:"</span> + count1);</span><br><span class="line">        System.out.println(<span class="string">"构造方法count2:"</span> + count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调下顺序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法count1:<span class="number">1</span></span><br><span class="line">构造方法count2:<span class="number">1</span></span><br><span class="line">count1:<span class="number">1</span></span><br><span class="line">count2:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>再修改下<code>Single</code>的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值赋为1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single single = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(<span class="string">"构造方法count1:"</span> + count1);</span><br><span class="line">        System.out.println(<span class="string">"构造方法count2:"</span> + count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法count1:<span class="number">2</span></span><br><span class="line">构造方法count2:<span class="number">1</span></span><br><span class="line">count1:<span class="number">2</span></span><br><span class="line">count2:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>经过上面的程序可以看出，静态变量的声明语句，以及静态代码块都被看做类的初始化语句，<code>Java</code>虚拟机会按照初始化语句在类文件中的先后顺序来依次执行它们。</p><h5 id="NO-5"><a href="#NO-5" class="headerlink" title="NO.5"></a>NO.5</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyTest7 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent7 parent7;</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line"><span class="comment">//        parent7 = new Parent7();</span></span><br><span class="line">        Son7 son7 = <span class="keyword">new</span> Son7();</span><br><span class="line">        System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">        System.out.println(Son7.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent7</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent7 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son7</span> <span class="keyword">extends</span> <span class="title">Parent7</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son7 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyTest7 invoked</span><br><span class="line">---------------</span><br><span class="line">Parent7 invoked</span><br><span class="line">Son7 invoked</span><br><span class="line">---------------</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示：首先使用<code>MyTest7</code>的启动类，导致了<code>MyTest7</code>的初始化，执行了静态代码块；然后声明了一个<code>Parent7</code>的变量，并不会导致<code>Parent7</code>的初始化；最后创建了一个<code>Son7</code>的实例，触发<code>Son7</code>的初始化，触发<code>Parent7</code>的初始化。</p></blockquote><p>将<code>Son7 son7 = new Son7();</code>替换为<code>parent7 = new Parent7();</code></p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyTest7 invoked</span><br><span class="line">---------------</span><br><span class="line">Parent7 invoked</span><br><span class="line">---------------</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示：只有<code>Parent7</code>初始化，而<code>Son7</code>并没有初始化。</p></blockquote><p>上述代码也印证了，在创建实例时以及启动类时，会导致类的初始化；当一个类初始化时，会先初始化它的父类。</p><h5 id="NO-6"><a href="#NO-6" class="headerlink" title="NO.6"></a>NO.6</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Son8.a);</span></span><br><span class="line">        Son8.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent8</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent8 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent8'doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son8</span> <span class="keyword">extends</span> <span class="title">Parent8</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Son8 invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent8 invoked</span><br><span class="line">Parent8<span class="string">'doSomething</span></span><br></pre></td></tr></table></figure><blockquote><p>输出结果显示：<code>Parent8</code>被初始化了。</p></blockquote><p>调用类的静态方法时，会导致类的初始化。</p><h5 id="NO-7"><a href="#NO-7" class="headerlink" title="NO.7"></a>NO.7</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       staticFunction();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">"1"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">"2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   StaticTest()</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(<span class="string">"3"</span>);</span><br><span class="line">       System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"4"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">110</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">112</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">a=110,b=0</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>在准备阶段：</p><ul><li>st = null，b = 0</li></ul><p>调用类的静态方法、且为启动类，将类进行初始化，顺序执行静态语句：</p><ul><li><p>初始化st</p><ul><li>首先执行代码块，打印出2</li><li>然后执行构造方法，打印3，以及a=110，此时b还未初始化，即b=0</li></ul></li><li><p>执行静态代码块，打印出1</p></li></ul><p>执行静态方法：</p><ul><li>打印出4</li></ul><h5 id="NO-8"><a href="#NO-8" class="headerlink" title="NO.8"></a>NO.8</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个系统加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="comment">//使用这个加载器去加载ClassLoad类，得到一个class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"classLoader.ClassLoad"</span>);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        <span class="comment">//使用反射获取class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass1 = Class.forName(<span class="string">"classLoader.ClassLoad"</span>);</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line">        System.out.println(aClass == aClass1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoad</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"CL invoked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classLoader</span>.<span class="title">ClassLoad</span></span></span><br><span class="line"><span class="class">-----------</span></span><br><span class="line"><span class="class"><span class="title">CL</span> <span class="title">invoked</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">classLoader</span>.<span class="title">ClassLoad</span></span></span><br><span class="line"><span class="class"><span class="title">true</span></span></span><br></pre></td></tr></table></figure><blockquote><p>关于类加载器（<a href="/2019/03/14/类加载机制（三）：类的加载与类加载器">类加载机制（三）：类的加载与类加载器</a>）</p></blockquote><p>可以看出调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。而使用反射则是对类的主动使用，会触发初始化，并且两个<code>class</code>对象是同一个，这也印证了前文所说的<code>class</code>对象在内存中只会存在一个的说法。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>​        类的初始化是类加载过程的最后阶段，在前面的类加载过程中，都是有虚拟机来进行主导和控制（除了用户可以自定义类加载外，请看我后续博客），到了初始化阶段，才真正开始执行<code>Java</code>程序中的字节码。</p><p>​        在连接中的准备阶段，静态变量被赋予了默认值，到了初始化阶段，这些变量才被赋予真正的值。在对类进行初始化时，<code>Java</code>虚拟机会按照初始化语句在类文件中的先后顺序来一次执行它们。</p><p>​        一个类只有在被<em>首次主动使用</em>才会触发初始化阶段，也只有上文提到的七种方式才算主动使用，其他都是被动使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类的初始化&quot;&gt;&lt;a href=&quot;#类的初始化&quot; class=&quot;headerlink&quot; title=&quot;类的初始化&quot;&gt;&lt;/a&gt;类的初始化&lt;/h2&gt;&lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://wuyuzhao666.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="类的初始化" scheme="http://wuyuzhao666.github.io/tags/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
