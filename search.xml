<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F02%2FArrayList%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2FArrayList%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList的基本原理 ArrayList是我们平时编码经常用到的动态数组容器类，要想分析它的原理，我们先来看看一个简易的DynamicArray类（摘自Java编程的逻辑） 一个简易的动态数组类public static class DynamicArray&lt;E&gt;{ private static final int DEFAULT_CAPACITY = 10; private int size; private Object[] elementData; public Dynamicarray() { this.elementData = new Object[DEFAULT_CAPACITY]; } public void ensureCapacity(int minCapacity){ int oldCapacity = elementData.length; if(oldCapacity &gt;= minCapacity){ return; } int newCapacity = oldCapacity * 2; if(newCapacity &lt; minCapacity){ newCapacity = minCapacity; } elementData = Arrays.copyOf(elementData,newCapacity); } public void add(E e){ ensureCapacity(size + 1); elementData[size++] = e; } public E get(int index){ return (E) elementData[index]; } public E set(int index,E e){ E e1 = get(index); elementData[index] = e; return e1; } } 在这个类中，定义了一个内部数组elementData，数组元素个数size，一个静态常量DEFAULT_CAPACITY,它表示数组的默认空间大小。这个动态数组类的操作基本都是基于内部数组element和size。ensureCapacity方法,在每次做add操作时，都会被调用，它是检查当前数组容量，并增大容量，然后根据新的容量，复制原来数组的。 ArrayList源码解析： ArrayList的基本原理与上文中的动态数组类是差不多的，它同样有静态常量默认空间，实例变量内部数组、元素个数。同样，内部方法基本都是操作elementData这个数组，size实时记录着这个数组的大小，首先我们从add方法说起（各源码内注释已说明白，就不再叙述）。 添加方法add(E e)： public boolean add(E e) { //首先，调用ensureCapacityInternal方法，确保数组容量够。将当前元素个数加一，即最小容量minCapacity传入方法。 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 检查数组容量方法ensureCapacityInternal(int minCapacity)： private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { //如果数组为空，则返回默认值与minCapacity之间的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; //如果minCapacity大于当前数组的长度，就调用grow方法增大容量, if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } modCount++表示内部的修改次数，而这个参数与arrayList的迭代有关,下篇博客再讲解。 增大数组容量grow方法(int minCapacity)： private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; //定义一个新的容量newCapacity，它的值为当前容量右移一位，即除以2，再加上当前数组容量，即当前数组容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果还小于当前元素个数加一，新的容量就等于minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果newCapacity大于一个静态常量MAX_ARRAY_SIZE，就调用hugeCapacity方法， 将newCapacity设定为Integer包装类的最大值0x7fffffff,其中MAX_ARRAY_SIZE为Integer.MAX_VALUE-8， 减8是因为在一些vm中，在数组中会保留一些头信息，尝试分配更大的数组可能导致OutOfMemoryError: 请求的数组大小超过VM限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //以newCapacity为数组size，创建了一个新的数组，复制原内容，赋值给elementData elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); //如果minCapacity还大于MAX_ARRAY_SIZE，就返回Integer的最大值0x7fffffff return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 再来看看remove(int index)方法: public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); //计算出需要移动多少位 int numMoved = size - index - 1; if (numMoved &gt; 0) //移动数组 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将size减1，GC会回收未经使用的对象 elementData[--size] = null; // clear to let GC do its work return oldValue; } 这里modCount依旧加一。 结论 上面，我们介绍了ArrayList的add和remove方法，其他方法也都是对内部数组elementData和元素个数size的操作，就不再探究了。总之，ArrayList就是一个动态数组，实现动态的原理，就是对内部的elementData、size和默认空间DEFAULT_CAPACITY进行操作。创建ArrayList时，会默认初始化一个DEFAULT_CAPACITY大小的数组。每次要做增加操作，就进行数组容量检查，若不够，就增加容量，做删除操作，size就减一，保持size实时记录当前元素个数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[包装类的缓存机制]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[包装类的缓存机制与valueOf()引言Java有8种基本类型，每种都有一个包装类型，有很多静态方法、变量等，方便对数据进行操作。包装类可以由valueOf()静态方法去创建，也可以用new关键字去创建实例对象，但为什么推荐使用valueOf()来创建呢。 首先，我们来看一个例子: public class Test { public static void main(String[] args) { Integer a = 1; Integer b = 1; Integer c = 128; Integer d = 128; if(a == b){ System.out.println(&quot;a与b相同&quot;); } if(c == d){ System.out.println(&quot;c与d相同&quot;); } } } 运行结果 ​ a与b相同 c与d不相同 ​ 分析 这段代码创建了4个Integer类型的对象实例a、b、c、d，照常理来说，4个对象，其引用地址不同，此例子的输出应该都为不相同，但结果确是a与b相同，c与d不同，这是为什么？ 此处我们是采用自动装箱的方式来创建的Integer对象，而这相当于调用了valueOf()的方法，所以就得从valueOf()这个静态方法说起。 ###valueof的分析 首先，看看Integer的valueOf()方法的源码 public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 分析 此段代码中如果不满足i&gt;=IntegerCache.low &amp;&amp; i&lt;= IntegerCache.high这个表达式，就通过new来得到对象，如果满足呢？ 再来看看IntegerCache类，IntegCache类是Integer类的一个内部静态类，其源码如下。 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 分析 首先，从Javadoc中看出这个类是用来实现缓存的。它定义了三个静态参数，缓存数组cache,数组最小值low，赋值为-128以及数组最大值high，最大值映射到了“java.lang.Integer.IntegerCache.high”上。 ，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 修改jvm参数后 ​ 运行结果 ​ a与b相同 c与d不相同 结论IntegerCache这个Integer私有静态类代表Integer缓存，它在被首次主动使用时，会被初始化，static代码块中的会被执行，通过一个 for 循环创建出一个值为-128~127的一个缓存数组cache，以后，如果创建的值在low和high之间，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。这种机制使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的，通过使用共享对象，就可以节省内存空间了。在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。这种机制在其他包装类中也有类似的实现。这种缓存策略也是一种设计模式，叫做享元模式。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
